design_name,task_id,prompt,ref_solution,testbench
fsm,ni_4_nn_4_ne_8_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                if (((in_D || in_C) == 'd0)) begin
                    next_state = S0;
                end
                else if (((in_C <= 'd1) != in_A)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_2_1,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
                next_state = S0;
            end
            S2: begin
                if ((in_A <= 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                next_state = S2;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_2_2,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                if (~|(in_B)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                next_state = S3;
            end
            S3: begin
                if (((in_A && in_B) != 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_2_3,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_D > 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                next_state = S2;
            end
            S2: begin
                next_state = S0;
            end
            S3: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_2_4,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (~&(in_A)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                if ((~^(in_D) != 'd0)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S0;
                end
            end
            S2: begin
                next_state = S1;
            end
            S3: begin
                if (((in_A != 'd0) == 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                if ((in_A || in_D)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if ((in_A && in_B)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_3_1,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_B && in_D) && (in_A <= 'd0))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                next_state = S2;
            end
            S2: begin
                next_state = S0;
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_3_2,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                if ((~^(in_B) && in_C)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                next_state = S1;
            end
            S3: begin
                if (((in_D && in_C) == ~(in_B))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_3_3,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
                next_state = S2;
            end
            S2: begin
                if ((in_D == 'd1)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if (((in_C && in_D) ^ |(in_A))) begin
                    next_state = S1;
                end
                else if ((in_A <= (in_B > in_C))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_3_4,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                if ((in_A && in_B)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                if ((in_A == 'd0)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if (((in_B || in_A) != 'd1)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S1;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                if (&((in_A == in_C))) begin
                    next_state = S0;
                end
                else if ((in_A ^ (in_B && in_C))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                next_state = S3;
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_4_1,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_D || in_C)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
            end
            S2: begin
                next_state = S3;
            end
            S3: begin
                if (((in_A != 'd1) || (in_D == in_B))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_4_2,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_D < in_A) ^ (in_D != 'd1))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                next_state = S0;
            end
            S3: begin
                if (|(in_A)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S1;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_4_3,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                if ((in_A == 'd0)) begin
                    next_state = S3;
                end
                else if (((in_A == 'd1) <= 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if (((in_B && in_A) && in_D)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_4_4,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                if (!(in_C)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if (((in_C > in_B) && in_C)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_A != 'd1)) begin
                    next_state = S1;
                end
                else if ((in_B || (in_C || in_D))) begin
                    next_state = S2;
                end
                else if (((in_C || in_B) <= in_C)) begin
                    next_state = S6;
                end
                else if ((in_D ^ in_B)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S8;
                end
            end
            S1: begin
                next_state = S11;
            end
            S2: begin
                next_state = S14;
            end
            S3: begin
                next_state = S0;
            end
            S4: begin
                if (((in_B == 'd0) == 'd1)) begin
                    next_state = S11;
                end
                else if (((in_D || in_B) ^ in_A)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S7;
                end
            end
            S5: begin
            end
            S6: begin
                if ((in_A <= 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S9;
                end
            end
            S7: begin
                next_state = S15;
            end
            S8: begin
            end
            S9: begin
                if (~&(in_D)) begin
                    next_state = S5;
                end
                else if (((in_D == 'd0) && in_C)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S13;
                end
            end
            S10: begin
                next_state = S12;
            end
            S11: begin
                next_state = S1;
            end
            S12: begin
                if ((in_D >= 'd0)) begin
                    next_state = S15;
                end
                else if ((~|(in_B) && (in_C || in_B))) begin
                    next_state = S13;
                end
                else if ((in_A && in_B)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S13: begin
                if ((in_B && (in_A != 'd0))) begin
                    next_state = S9;
                end
                else if (~(in_B)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S3;
                end
            end
            S14: begin
                next_state = S3;
            end
            S15: begin
                if ((in_D || in_B)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_2_1,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S15;
            end
            S1: begin
                next_state = S0;
            end
            S2: begin
                if ((in_D == (in_A != 'd1))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S13;
                end
            end
            S3: begin
                if ((in_C != in_A)) begin
                    next_state = S9;
                end
                else if (((in_A && in_D) == in_B)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S14;
                end
            end
            S4: begin
                next_state = S3;
            end
            S5: begin
            end
            S6: begin
                if ((in_B != 'd0)) begin
                    next_state = S7;
                end
                else if (((in_A || in_C) < in_A)) begin
                    next_state = S10;
                end
                else if (((in_C || in_A) ^ (in_C || in_A))) begin
                    next_state = S14;
                end
                else if (((in_D ^ in_A) || (in_D || in_C))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
                if (&((in_B ^ in_D))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S8;
                end
            end
            S8: begin
                next_state = S6;
            end
            S9: begin
            end
            S10: begin
                if ((in_D != (in_A && in_B))) begin
                    next_state = S1;
                end
                else if ((in_C != 'd1)) begin
                    next_state = S15;
                end
                else if (((in_B == 'd0) && (in_C != in_B))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S8;
                end
            end
            S11: begin
                next_state = S8;
            end
            S12: begin
            end
            S13: begin
                if ((in_A <= 'd1)) begin
                    next_state = S2;
                end
                else if (((in_A != 'd1) != 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S15;
                end
            end
            S14: begin
                if (((in_D == in_C) || &(in_B))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S13;
                end
            end
            S15: begin
                if (((in_A == 'd0) || in_D)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S14;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_2_2,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_C == (in_B < in_C))) begin
                    next_state = S6;
                end
                else if ((~^(in_C) || (in_B != 'd0))) begin
                    next_state = S12;
                end
                else if (!(in_A)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S14;
                end
            end
            S1: begin
                if (^((in_C != in_D))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S9;
                end
            end
            S2: begin
                if (((in_B == 'd0) != 'd0)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S15;
                end
            end
            S3: begin
                if ((in_B && in_C)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S7;
                end
            end
            S4: begin
                if (~^((in_A || in_B))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S11;
                end
            end
            S5: begin
                next_state = S14;
            end
            S6: begin
                if (((in_B == 'd1) < (in_C ^ in_D))) begin
                    next_state = S8;
                end
                else if (|(in_B)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S7;
                end
            end
            S7: begin
                next_state = S1;
            end
            S8: begin
                next_state = S4;
            end
            S9: begin
                if ((in_D ^ &(in_B))) begin
                    next_state = S14;
                end
                else begin
                    next_state = S6;
                end
            end
            S10: begin
                next_state = S3;
            end
            S11: begin
                next_state = S2;
            end
            S12: begin
                if (((in_D && in_A) >= (in_C == 'd0))) begin
                    next_state = S0;
                end
                else if (((in_D == 'd1) || (in_C && in_B))) begin
                    next_state = S4;
                end
                else if (((in_D == in_A) != 'd0)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S2;
                end
            end
            S13: begin
            end
            S14: begin
                next_state = S15;
            end
            S15: begin
                if ((in_A && (in_D ^ in_C))) begin
                    next_state = S9;
                end
                else if ((in_B == 'd0)) begin
                    next_state = S10;
                end
                else if ((in_B == 'd0)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S4;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_2_3,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (&(in_D)) begin
                    next_state = S5;
                end
                else if (((in_D != 'd1) != (in_C == in_B))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S13;
                end
            end
            S1: begin
                next_state = S7;
            end
            S2: begin
                if ((in_C || (in_D == 'd1))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S10;
                end
            end
            S3: begin
                next_state = S8;
            end
            S4: begin
                if ((in_A && in_D)) begin
                    next_state = S14;
                end
                else if (((in_D == 'd0) || (in_C || in_B))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S12;
                end
            end
            S5: begin
                if (^((in_D == in_B))) begin
                    next_state = S2;
                end
                else if (((in_A > 'd1) != (in_C && in_D))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S13;
                end
            end
            S6: begin
                if (((in_D < 'd1) ^ in_B)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S4;
                end
            end
            S7: begin
                if (((in_A != 'd1) || ~^(in_D))) begin
                    next_state = S4;
                end
                else if ((in_D != 'd1)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S3;
                end
            end
            S8: begin
                if (!(&(in_A))) begin
                    next_state = S6;
                end
                else if (&(~(in_A))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S15;
                end
            end
            S9: begin
            end
            S10: begin
                if ((in_B > 'd0)) begin
                    next_state = S0;
                end
                else if (((in_D != 'd0) ^ (in_C && in_A))) begin
                    next_state = S3;
                end
                else if (~&(~(in_D))) begin
                    next_state = S15;
                end
                else if ((in_C && in_B)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S12;
                end
            end
            S11: begin
            end
            S12: begin
                if (((in_C || in_B) != 'd0)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S15;
                end
            end
            S13: begin
                if ((|(in_A) == 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S6;
                end
            end
            S14: begin
                next_state = S9;
            end
            S15: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_2_4,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_A && in_C)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S8;
                end
            end
            S1: begin
            end
            S2: begin
                if ((in_B == in_D)) begin
                    next_state = S3;
                end
                else if (((in_A < 'd1) || (in_C < 'd1))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S12;
                end
            end
            S3: begin
                next_state = S14;
            end
            S4: begin
                if (((in_C || in_D) && (in_C && in_B))) begin
                    next_state = S15;
                end
                else begin
                    next_state = S5;
                end
            end
            S5: begin
                if ((|(in_C) && ~&(in_A))) begin
                    next_state = S15;
                end
                else if ((in_A && ~(in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S7;
                end
            end
            S6: begin
                next_state = S7;
            end
            S7: begin
                if ((&(in_B) == in_D)) begin
                    next_state = S0;
                end
                else if ((in_C && in_D)) begin
                    next_state = S2;
                end
                else if (((in_B ^ in_A) == 'd1)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S8;
                end
            end
            S8: begin
                if ((in_A != in_D)) begin
                    next_state = S9;
                end
                else if (!((in_A || in_B))) begin
                    next_state = S10;
                end
                else begin
                    next_state = S12;
                end
            end
            S9: begin
                next_state = S6;
            end
            S10: begin
                if ((in_D == (in_B != 'd1))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S4;
                end
            end
            S11: begin
                if ((in_D != in_B)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S13;
                end
            end
            S12: begin
                if (^(~&(in_B))) begin
                    next_state = S10;
                end
                else begin
                    next_state = S11;
                end
            end
            S13: begin
                if ((in_C == 'd1)) begin
                    next_state = S1;
                end
                else if (|(&(in_C))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S7;
                end
            end
            S14: begin
                if ((in_C != 'd1)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S1;
                end
            end
            S15: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S5;
            end
            S1: begin
                if (((in_D ^ in_B) >= (in_C == 'd1))) begin
                    next_state = S10;
                end
                else if ((in_B ^ ~|(in_C))) begin
                    next_state = S11;
                end
                else if (((in_D ^ in_C) && (in_A == 'd1))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S5;
                end
            end
            S2: begin
                next_state = S8;
            end
            S3: begin
                if ((in_C != 'd1)) begin
                    next_state = S2;
                end
                else if (((in_C > in_A) || (in_B || in_D))) begin
                    next_state = S12;
                end
                else if ((in_C && in_A)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S6;
                end
            end
            S4: begin
            end
            S5: begin
                if (~((in_C || in_B))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S2;
                end
            end
            S6: begin
                if (((in_D && in_C) != (in_B == 'd0))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
                next_state = S15;
            end
            S8: begin
                if (^(in_A)) begin
                    next_state = S5;
                end
                else if ((!(in_C) != 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S3;
                end
            end
            S9: begin
                if (((in_D > 'd1) || !(in_C))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S13;
                end
            end
            S10: begin
                if ((in_A || (in_D != in_C))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S3;
                end
            end
            S11: begin
                next_state = S4;
            end
            S12: begin
                if (((in_D == in_A) && (in_C ^ in_B))) begin
                    next_state = S3;
                end
                else if ((in_A ^ (in_C != 'd0))) begin
                    next_state = S5;
                end
                else if ((in_A > 'd1)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S2;
                end
            end
            S13: begin
            end
            S14: begin
                if ((in_C ^ in_B)) begin
                    next_state = S0;
                end
                else if ((in_C || in_A)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S6;
                end
            end
            S15: begin
                if (((in_C != 'd1) <= 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_3_1,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_B && in_D) && ~|(in_B))) begin
                    next_state = S7;
                end
                else if (~|((in_A != in_B))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S8;
                end
            end
            S1: begin
                if (&(in_A)) begin
                    next_state = S4;
                end
                else if ((~|(in_A) != 'd1)) begin
                    next_state = S6;
                end
                else if ((in_B >= 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S0;
                end
            end
            S2: begin
                next_state = S6;
            end
            S3: begin
                if ((in_C ^ !(in_B))) begin
                    next_state = S0;
                end
                else if (((in_B || in_C) == 'd1)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S2;
                end
            end
            S4: begin
                if (&(in_C)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S5: begin
                next_state = S8;
            end
            S6: begin
                if (((in_B || in_C) < in_B)) begin
                    next_state = S2;
                end
                else if ((in_B != 'd1)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S11;
                end
            end
            S7: begin
                next_state = S9;
            end
            S8: begin
                if ((~|(in_A) > (in_C ^ in_B))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
            S9: begin
                if (((in_A ^ in_C) == 'd0)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S13;
                end
            end
            S10: begin
                if (((in_C ^ in_A) && in_D)) begin
                    next_state = S12;
                end
                else if ((in_B && ~^(in_D))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S3;
                end
            end
            S11: begin
                next_state = S6;
            end
            S12: begin
                next_state = S8;
            end
            S13: begin
                if ((in_B == 'd1)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S15;
                end
            end
            S14: begin
                if (^(in_C)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S13;
                end
            end
            S15: begin
                next_state = S9;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_3_2,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                if (~&(in_B)) begin
                    next_state = S6;
                end
                else if (((in_B > 'd1) ^ in_A)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S9;
                end
            end
            S2: begin
                if ((~^(in_C) ^ (in_D ^ in_B))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S5;
                end
            end
            S3: begin
                if (!(in_C)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S2;
                end
            end
            S4: begin
                next_state = S0;
            end
            S5: begin
            end
            S6: begin
                if (((in_D ^ in_A) == (in_D && in_C))) begin
                    next_state = S10;
                end
                else begin
                    next_state = S9;
                end
            end
            S7: begin
                if ((~^(in_B) == (in_C < 'd1))) begin
                    next_state = S14;
                end
                else begin
                    next_state = S3;
                end
            end
            S8: begin
                if (~((in_A || in_C))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S10;
                end
            end
            S9: begin
                if ((in_A && (in_B || in_A))) begin
                    next_state = S2;
                end
                else if (((in_B ^ in_C) == 'd1)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
            S10: begin
                next_state = S13;
            end
            S11: begin
            end
            S12: begin
                if (((in_A || in_C) ^ in_D)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S2;
                end
            end
            S13: begin
                if ((in_D || in_C)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S5;
                end
            end
            S14: begin
                if ((in_D || (in_A && in_D))) begin
                    next_state = S5;
                end
                else if ((in_D == 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S9;
                end
            end
            S15: begin
                if (((in_D && in_A) && in_D)) begin
                    next_state = S12;
                end
                else if ((in_D || |(in_B))) begin
                    next_state = S6;
                end
                else if ((in_B == (in_D || in_C))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S10;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_3_3,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (~|(in_A)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                next_state = S7;
            end
            S2: begin
                next_state = S1;
            end
            S3: begin
                if (((in_D != 'd0) <= 'd1)) begin
                    next_state = S4;
                end
                else if ((in_C != 'd0)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S14;
                end
            end
            S4: begin
                next_state = S1;
            end
            S5: begin
                if (((in_D || in_C) ^ in_A)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S14;
                end
            end
            S6: begin
            end
            S7: begin
                next_state = S2;
            end
            S8: begin
                if (((in_D || in_C) == 'd0)) begin
                    next_state = S14;
                end
                else if (~^(in_A)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S9;
                end
            end
            S9: begin
                if (((in_A || in_B) || in_A)) begin
                    next_state = S1;
                end
                else if ((in_C && in_D)) begin
                    next_state = S6;
                end
                else if ((~|(in_C) ^ in_B)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S8;
                end
            end
            S10: begin
                if (((in_D != 'd0) || in_C)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S3;
                end
            end
            S11: begin
                if ((in_D == in_A)) begin
                    next_state = S0;
                end
                else if (((in_B && in_C) != 'd1)) begin
                    next_state = S3;
                end
                else if ((in_D || in_B)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S12: begin
            end
            S13: begin
                if ((in_D != 'd0)) begin
                    next_state = S10;
                end
                else if (((in_B && in_A) && (in_D == 'd1))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S8;
                end
            end
            S14: begin
                if (((in_B == 'd1) == in_D)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S5;
                end
            end
            S15: begin
                next_state = S9;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_3_4,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_A != 'd0)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S10;
                end
            end
            S1: begin
                if ((in_C || in_B)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S12;
                end
            end
            S2: begin
                if ((~^(in_B) || ~(in_D))) begin
                    next_state = S1;
                end
                else if ((in_A || in_D)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S5;
                end
            end
            S3: begin
                if ((in_C == 'd1)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S15;
                end
            end
            S4: begin
                if ((in_A || (in_B && in_C))) begin
                    next_state = S7;
                end
                else if (((in_C == 'd0) > in_B)) begin
                    next_state = S14;
                end
                else if ((in_A >= 'd0)) begin
                    next_state = S15;
                end
                else if ((in_B || in_A)) begin
                    next_state = S10;
                end
                else if ((~|(in_A) != 'd0)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S13;
                end
            end
            S5: begin
                next_state = S11;
            end
            S6: begin
            end
            S7: begin
                next_state = S13;
            end
            S8: begin
                if ((in_A || in_B)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S9;
                end
            end
            S9: begin
            end
            S10: begin
                if (~((in_A ^ in_B))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S6;
                end
            end
            S11: begin
                if (((in_C && in_D) == (in_A <= 'd1))) begin
                    next_state = S8;
                end
                else if ((in_B <= 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S13;
                end
            end
            S12: begin
                if (((in_C != 'd0) <= (in_B != in_D))) begin
                    next_state = S3;
                end
                else if (!(in_B)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S8;
                end
            end
            S13: begin
                next_state = S5;
            end
            S14: begin
            end
            S15: begin
                if (((in_C == 'd0) == 'd1)) begin
                    next_state = S2;
                end
                else if ((in_D ^ (in_C == 'd0))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S9;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S4;
            end
            S1: begin
                if (~&(in_B)) begin
                    next_state = S8;
                end
                else if (((in_A != 'd1) && &(in_B))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
                next_state = S14;
            end
            S3: begin
                next_state = S7;
            end
            S4: begin
                if ((in_D ^ in_B)) begin
                    next_state = S5;
                end
                else if (!((in_C && in_B))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S12;
                end
            end
            S5: begin
                if ((|(in_C) == 'd0)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S3;
                end
            end
            S6: begin
            end
            S7: begin
                if ((in_D == 'd1)) begin
                    next_state = S10;
                end
                else if (((in_B == in_A) ^ (in_B ^ in_A))) begin
                    next_state = S13;
                end
                else if (((in_A || in_B) ^ (in_C == 'd0))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S3;
                end
            end
            S8: begin
                if (((in_C == 'd1) ^ (in_B == 'd0))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S9: begin
                if (((in_B ^ in_D) || in_C)) begin
                    next_state = S6;
                end
                else if (((in_B && in_D) != 'd0)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S12;
                end
            end
            S10: begin
                if ((~(in_C) || in_A)) begin
                    next_state = S15;
                end
                else if (|((in_D || in_B))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S4;
                end
            end
            S11: begin
                if (((in_C ^ in_D) == 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S2;
                end
            end
            S12: begin
                if (((in_B != 'd0) || (in_C == 'd0))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S7;
                end
            end
            S13: begin
            end
            S14: begin
                if ((in_C && (in_B != 'd1))) begin
                    next_state = S9;
                end
                else if ((in_B && in_D)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S1;
                end
            end
            S15: begin
                next_state = S3;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_4_1,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S9;
            end
            S1: begin
                if (((in_D == 'd1) != 'd1)) begin
                    next_state = S3;
                end
                else if ((in_D != in_C)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
                if ((in_C ^ (in_D == in_B))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S11;
            end
            S4: begin
                if (((in_C == 'd1) || in_B)) begin
                    next_state = S2;
                end
                else if ((in_B < 'd1)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S0;
                end
            end
            S5: begin
            end
            S6: begin
                if (((in_A ^ in_C) < (in_B || in_A))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S12;
                end
            end
            S7: begin
                if ((in_D <= (in_A != in_D))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S8: begin
                next_state = S6;
            end
            S9: begin
                if (!(|(in_B))) begin
                    next_state = S10;
                end
                else begin
                    next_state = S4;
                end
            end
            S10: begin
                next_state = S13;
            end
            S11: begin
                if (!(in_B)) begin
                    next_state = S7;
                end
                else if (~((in_C || in_D))) begin
                    next_state = S8;
                end
                else if (((in_C == in_A) ^ in_C)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S15;
                end
            end
            S12: begin
                if (~|((in_A <= 'd1))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S9;
                end
            end
            S13: begin
                if ((^(in_D) != 'd0)) begin
                    next_state = S14;
                end
                else if (((in_C > 'd0) && in_D)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
            S14: begin
                next_state = S6;
            end
            S15: begin
                if (((in_A != in_D) || (in_B ^ in_D))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_4_2,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S8;
            end
            S1: begin
                if (((in_D != 'd0) ^ in_A)) begin
                    next_state = S2;
                end
                else if ((~|(in_B) == in_A)) begin
                    next_state = S6;
                end
                else if ((in_D && in_B)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S12;
                end
            end
            S2: begin
                if (~(in_A)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S15;
                end
            end
            S3: begin
                if (((in_B != 'd0) > 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S9;
                end
            end
            S4: begin
                if (!(in_B)) begin
                    next_state = S1;
                end
                else if (|((in_D || in_C))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S7;
                end
            end
            S5: begin
                if (((in_C && in_B) || in_C)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S9;
                end
            end
            S6: begin
                if (((in_A == 'd1) != 'd0)) begin
                    next_state = S0;
                end
                else if ((in_B ^ in_C)) begin
                    next_state = S12;
                end
                else if (((in_D == 'd0) || in_C)) begin
                    next_state = S7;
                end
                else if ((in_A ^ in_C)) begin
                    next_state = S2;
                end
                else if ((in_B && in_C)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S5;
                end
            end
            S7: begin
                if (((in_B > 'd0) ^ (in_C && in_B))) begin
                    next_state = S3;
                end
                else if (((in_A ^ in_C) && in_D)) begin
                    next_state = S10;
                end
                else if (((in_C == 'd0) != (in_D && in_A))) begin
                    next_state = S15;
                end
                else begin
                    next_state = S12;
                end
            end
            S8: begin
                next_state = S4;
            end
            S9: begin
                if (~|(in_D)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S13;
                end
            end
            S10: begin
                next_state = S15;
            end
            S11: begin
            end
            S12: begin
                if (((in_B >= 'd1) || in_A)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S8;
                end
            end
            S13: begin
                next_state = S6;
            end
            S14: begin
            end
            S15: begin
                next_state = S2;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_4_3,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                next_state = S10;
            end
            S2: begin
                if (((in_D || in_A) != 'd0)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S11;
                end
            end
            S3: begin
                next_state = S2;
            end
            S4: begin
                next_state = S11;
            end
            S5: begin
                if (((in_D ^ in_B) != 'd0)) begin
                    next_state = S6;
                end
                else if (|((in_D != in_A))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S10;
                end
            end
            S6: begin
                if ((in_B || (in_C || in_D))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
            end
            S8: begin
                next_state = S0;
            end
            S9: begin
                next_state = S6;
            end
            S10: begin
                if (((in_A != 'd0) && in_C)) begin
                    next_state = S9;
                end
                else if (~^(in_C)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S12;
                end
            end
            S11: begin
                if ((~&(in_C) ^ ~&(in_D))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S15;
                end
            end
            S12: begin
                next_state = S5;
            end
            S13: begin
                if (((in_A || in_B) != 'd0)) begin
                    next_state = S7;
                end
                else if ((in_A || (in_B || in_A))) begin
                    next_state = S8;
                end
                else if ((in_A != 'd0)) begin
                    next_state = S10;
                end
                else if (((in_A == 'd1) && (in_B ^ in_A))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S2;
                end
            end
            S14: begin
                if ((~^(in_D) != in_B)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S3;
                end
            end
            S15: begin
                if (((in_D != 'd1) ^ in_C)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S7;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_4_4,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S5;
            end
            S1: begin
                next_state = S0;
            end
            S2: begin
                if ((in_B == (in_C && in_D))) begin
                    next_state = S4;
                end
                else if (((in_A == 'd1) && (in_D <= 'd1))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S9;
                end
            end
            S3: begin
                if (!((in_A >= 'd1))) begin
                    next_state = S6;
                end
                else if ((in_B != 'd0)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S11;
                end
            end
            S4: begin
                next_state = S11;
            end
            S5: begin
                if (((in_B != in_D) == (in_A == 'd1))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S6: begin
                next_state = S4;
            end
            S7: begin
                if (&((in_A != 'd0))) begin
                    next_state = S0;
                end
                else if ((~&(in_A) == (in_B || in_C))) begin
                    next_state = S1;
                end
                else if (((in_D ^ in_B) == 'd0)) begin
                    next_state = S9;
                end
                else if (((in_A || in_D) != (in_A || in_C))) begin
                    next_state = S15;
                end
                else if ((in_C == (in_A != 'd0))) begin
                    next_state = S10;
                end
                else if (~|(in_D)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S14;
                end
            end
            S8: begin
                if ((~|(in_D) ^ |(in_C))) begin
                    next_state = S11;
                end
                else if ((in_A ^ (in_B || in_A))) begin
                    next_state = S12;
                end
                else if ((in_B != (in_D ^ in_A))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S9: begin
                next_state = S13;
            end
            S10: begin
                if (((in_A || in_D) ^ in_B)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S14;
                end
            end
            S11: begin
            end
            S12: begin
            end
            S13: begin
                if (((in_D && in_B) == (in_A != 'd1))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S3;
                end
            end
            S14: begin
                if (((in_C != 'd0) != 'd0)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S4;
                end
            end
            S15: begin
                if ((~^(in_C) ^ (in_B == 'd1))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S13;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
