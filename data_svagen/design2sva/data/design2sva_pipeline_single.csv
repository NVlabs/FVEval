design_name,task_id,prompt,ref_solution,testbench
pipeline_single,ns_2-w_128-opd_2-0,"`define WIDTH 128
`define DEPTH 4

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] & 8) ^ (data[i] - 9));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data <<< 2) ^ 10) - 2);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 4

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data & 8) ^ (in_data - 9));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 & 8) ^ (data_0 - 9));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 & 8) ^ (data_1 - 9));
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 <<< 2) ^ 10) - 2);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_3, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_128-opd_2-1,"`define WIDTH 128
`define DEPTH 2

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 1) + 2) ^ (in_data >>> 6));
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 8) & 10);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 2

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data ^ 8) & 10);
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 >>> 1) + 2) ^ (data_0 >>> 6));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_1, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_128-opd_3-0,"`define WIDTH 128
`define DEPTH 2

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 10) >>> ((in_data - 5) + 10));
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 2) + (in_data & 2)) - 3);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 2

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data | 2) + (in_data & 2)) - 3);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 ^ 10) >>> ((data_0 - 5) + 10));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_1, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_128-opd_3-1,"`define WIDTH 128
`define DEPTH 2

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data ^ 5) >>> (in_data - 4)) - (in_data ^ 7)) | ((in_data >>> 6) | (in_data ^ 2)));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 5) <<< 6);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 2

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((((in_data ^ 5) >>> (in_data - 4)) - (in_data ^ 7)) | ((in_data >>> 6) | (in_data ^ 2)));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 <<< 5) <<< 6);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_1, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_128-opd_4-0,"`define WIDTH 128
`define DEPTH 4

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data + 8) + 4);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((((data[i] <<< 4) ^ 10) - (data[i] ^ 2)) + (data[i] & 2));
                end
            end
        end
    endgenerate
endmodule



module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 4

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((((in_data <<< 4) ^ 10) - (in_data ^ 2)) + (in_data & 2));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((((data_0 <<< 4) ^ 10) - (data_0 ^ 2)) + (data_0 & 2));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((((data_1 <<< 4) ^ 10) - (data_1 ^ 2)) + (data_1 & 2));
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 + 8) + 4);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_3, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_128-opd_4-1,"`define WIDTH 128
`define DEPTH 2

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data | 4) | ((in_data - 4) <<< (in_data + 3))) & 6) >>> 5);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 3) & ((in_data & 6) <<< (in_data <<< 5)));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 2

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((((in_data | 4) | ((in_data - 4) <<< (in_data + 3))) & 6) >>> 5);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 | 3) & ((data_0 & 6) <<< (data_0 <<< 5)));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_1, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_256-opd_2-0,"`define WIDTH 256
`define DEPTH 7

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] - 4) + ((data[i] >>> 7) | (data[i] >>> 10)));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] & 10) & ((data[i] ^ 3) & (data[i] | 7)));
                end
            end
        end
    endgenerate
endmodule



module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 7

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data & 10) & ((in_data ^ 3) & (in_data | 7)));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 & 10) & ((data_0 ^ 3) & (data_0 | 7)));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 & 10) & ((data_1 ^ 3) & (data_1 | 7)));
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 - 4) + ((data_2 >>> 7) | (data_2 >>> 10)));
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 - 4) + ((data_3 >>> 7) | (data_3 >>> 10)));
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 - 4) + ((data_4 >>> 7) | (data_4 >>> 10)));
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((data_5 - 4) + ((data_5 >>> 7) | (data_5 >>> 10)));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_6, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_256-opd_2-1,"`define WIDTH 256
`define DEPTH 2

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 7) <<< 2) >>> (in_data | 6));
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 6) ^ (in_data | 1)) - 8);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 2

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data | 6) ^ (in_data | 1)) - 8);
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 + 7) <<< 2) >>> (data_0 | 6));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_1, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_256-opd_3-0,"`define WIDTH 256
`define DEPTH 5

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data ^ 8) ^ (in_data | 7)) - (in_data ^ 3)) - 5);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] >>> 5) + ((data[i] <<< 2) - ((data[i] ^ 6) | 2)));
                end
            end
        end
    endgenerate
endmodule



module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 5

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data >>> 5) + ((in_data <<< 2) - ((in_data ^ 6) | 2)));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 >>> 5) + ((data_0 <<< 2) - ((data_0 ^ 6) | 2)));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 >>> 5) + ((data_1 <<< 2) - ((data_1 ^ 6) | 2)));
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 >>> 5) + ((data_2 <<< 2) - ((data_2 ^ 6) | 2)));
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((((data_3 ^ 8) ^ (data_3 | 7)) - (data_3 ^ 3)) - 5);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_4, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_256-opd_3-1,"`define WIDTH 256
`define DEPTH 2

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 1) & 6);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 9) - 3);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 2

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data ^ 1) & 6);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 | 9) - 3);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_1, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_256-opd_4-0,"`define WIDTH 256
`define DEPTH 3

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 7) >>> 6);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] ^ 8) >>> 6) >>> 9);
                end
            end
        end
    endgenerate
endmodule



module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 3

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data ^ 8) >>> 6) >>> 9);
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 ^ 8) >>> 6) >>> 9);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 | 7) >>> 6);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_2, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_2-w_256-opd_4-1,"`define WIDTH 256
`define DEPTH 5

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] <<< 4) >>> 2);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data - 7) | ((in_data - 6) - 5)) + ((in_data <<< 4) >>> 1));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 5

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data <<< 4) >>> 2);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 <<< 4) >>> 2);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 <<< 4) >>> 2);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 <<< 4) >>> 2);
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 - 7) | ((data_3 - 6) - 5)) + ((data_3 <<< 4) >>> 1));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_4, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_128-opd_2-0,"`define WIDTH 128
`define DEPTH 6

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 7) + 10) | ((in_data <<< 4) | (in_data - 1)));
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data ^ 10) >>> (in_data >>> 1)) - (in_data + 3));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 10) - 5) <<< 6);
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] >>> 1) <<< 8);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 8) | (in_data ^ 7)) - ((in_data >>> 9) ^ (in_data + 7)));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 6

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data | 7) + 10) | ((in_data <<< 4) | (in_data - 1)));
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 | 10) - 5) <<< 6);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 >>> 1) <<< 8);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 >>> 1) <<< 8);
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 >>> 8) | (data_3 ^ 7)) - ((data_3 >>> 9) ^ (data_3 + 7)));
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((data_4 ^ 10) >>> (data_4 >>> 1)) - (data_4 + 3));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_5, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_128-opd_2-1,"`define WIDTH 128
`define DEPTH 6

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] <<< 2) <<< (data[i] <<< 10)) >>> 8);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 9) + (in_data - 7)) + 2);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data - 6) >>> (in_data ^ 8));
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data - 1) & (in_data | 6)) >>> 3);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 3) >>> 6);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 6

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data | 3) >>> 6);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 - 6) >>> (data_0 ^ 8));
    wire [WIDTH-1:0] data_2;
    assign data_2 = (((data_1 + 9) + (data_1 - 7)) + 2);
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 <<< 2) <<< (data_2 <<< 10)) >>> 8);
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 <<< 2) <<< (data_3 <<< 10)) >>> 8);
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((data_4 - 1) & (data_4 | 6)) >>> 3);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_5, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_128-opd_3-0,"`define WIDTH 128
`define DEPTH 8

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 2) ^ (((in_data >>> 6) | 7) >>> 3));
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 6) | (((in_data & 9) | (in_data >>> 3)) + 2));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data - 6) + 6) + 6);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] & 2) >>> 9);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data - 3) <<< 1) <<< 2) - ((in_data + 4) | 6));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 8

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data & 2) >>> 9);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 & 2) >>> 9);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 & 2) >>> 9);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 & 2) >>> 9);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 | 2) ^ (((data_3 >>> 6) | 7) >>> 3));
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((data_4 - 6) + 6) + 6);
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((((data_5 - 3) <<< 1) <<< 2) - ((data_5 + 4) | 6));
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((data_6 ^ 6) | (((data_6 & 9) | (data_6 >>> 3)) + 2));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_7, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_128-opd_3-1,"`define WIDTH 128
`define DEPTH 8

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data - 8) | 3) <<< 3) - (((in_data >>> 8) + 8) ^ (in_data + 4)));
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 9) <<< 6);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 8) | (in_data & 8));
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] <<< 8) >>> 5);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 1) | 4);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 8

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data & 9) <<< 6);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 & 8) | (data_0 & 8));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((((data_1 - 8) | 3) <<< 3) - (((data_1 >>> 8) + 8) ^ (data_1 + 4)));
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 <<< 8) >>> 5);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 <<< 8) >>> 5);
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 <<< 8) >>> 5);
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((data_5 <<< 8) >>> 5);
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((data_6 <<< 1) | 4);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_7, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_128-opd_4-0,"`define WIDTH 128
`define DEPTH 8

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((((data[i] - 10) + 7) ^ (data[i] - 9)) >>> 5);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] & 8) | 1) <<< 1);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 7) & 7);
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data + 7) + (((in_data >>> 10) >>> 5) + (in_data + 7)));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data <<< 3) >>> 5) <<< (((in_data | 7) - 9) <<< (in_data | 9)));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 8

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((((in_data - 10) + 7) ^ (in_data - 9)) >>> 5);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((((data_0 - 10) + 7) ^ (data_0 - 9)) >>> 5);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((((data_1 - 10) + 7) ^ (data_1 - 9)) >>> 5);
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 <<< 3) >>> 5) <<< (((data_2 | 7) - 9) <<< (data_2 | 9)));
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 & 8) | 1) <<< 1);
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((data_4 & 8) | 1) <<< 1);
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((data_5 + 7) + (((data_5 >>> 10) >>> 5) + (data_5 + 7)));
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((data_6 <<< 7) & 7);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_7, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_128-opd_4-1,"`define WIDTH 128
`define DEPTH 6

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 8) >>> ((in_data ^ 7) <<< (in_data | 5))) & ((in_data - 6) - 6));
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data & 8) & (in_data <<< 4)) >>> (in_data ^ 2));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] - 8) <<< 4) <<< (((data[i] & 1) & (data[i] - 6)) ^ 2));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data - 8) - 2) | 8) | ((((in_data & 6) - 3) | 1) >>> ((in_data >>> 4) + (in_data >>> 8))));
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data <<< 3) <<< 2) <<< 1);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 6

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data <<< 3) <<< 2) <<< 1);
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 | 8) >>> ((data_0 ^ 7) <<< (data_0 | 5))) & ((data_0 - 6) - 6));
    wire [WIDTH-1:0] data_2;
    assign data_2 = (((data_1 - 8) <<< 4) <<< (((data_1 & 1) & (data_1 - 6)) ^ 2));
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 - 8) <<< 4) <<< (((data_2 & 1) & (data_2 - 6)) ^ 2));
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 & 8) & (data_3 <<< 4)) >>> (data_3 ^ 2));
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((((data_4 - 8) - 2) | 8) | ((((data_4 & 6) - 3) | 1) >>> ((data_4 >>> 4) + (data_4 >>> 8))));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_5, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_256-opd_2-0,"`define WIDTH 256
`define DEPTH 8

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 5) ^ 9);
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] >>> 8) + (data[i] <<< 4)) | ((data[i] ^ 3) - 4));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 8) + ((in_data | 8) + 4));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data ^ 1) >>> 1) <<< 8);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 4) <<< 9) <<< (in_data & 6));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 8

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data | 5) ^ 9);
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 >>> 4) <<< 9) <<< (data_0 & 6));
    wire [WIDTH-1:0] data_2;
    assign data_2 = (((data_1 ^ 1) >>> 1) <<< 8);
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 >>> 8) + (data_2 <<< 4)) | ((data_2 ^ 3) - 4));
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 >>> 8) + (data_3 <<< 4)) | ((data_3 ^ 3) - 4));
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((data_4 >>> 8) + (data_4 <<< 4)) | ((data_4 ^ 3) - 4));
    wire [WIDTH-1:0] data_6;
    assign data_6 = (((data_5 >>> 8) + (data_5 <<< 4)) | ((data_5 ^ 3) - 4));
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((data_6 & 8) + ((data_6 | 8) + 4));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_7, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_256-opd_2-1,"`define WIDTH 256
`define DEPTH 7

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 6) + 4);
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 7) <<< (in_data - 1)) | ((in_data + 6) ^ (in_data >>> 3)));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] - 8) + 6);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 7) & 5);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] & 1) <<< ((data[i] + 8) ^ 1));
                end
            end
        end
    endgenerate
endmodule



module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 7

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data & 1) <<< ((in_data + 8) ^ 1));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 & 1) <<< ((data_0 + 8) ^ 1));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 <<< 6) + 4);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 - 8) + 6);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 - 8) + 6);
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 >>> 7) & 5);
    wire [WIDTH-1:0] data_6;
    assign data_6 = (((data_5 + 7) <<< (data_5 - 1)) | ((data_5 + 6) ^ (data_5 >>> 3)));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_6, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_256-opd_3-0,"`define WIDTH 256
`define DEPTH 5

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data + 8) >>> ((in_data - 7) & ((in_data ^ 5) >>> 8)));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 5) & (((in_data & 3) - (in_data - 6)) ^ (in_data >>> 1)));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 6) <<< ((in_data <<< 10) + 5)) + 9);
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 5) + 10);
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data <<< 5) & 1) + 3) >>> ((in_data >>> 3) - 2));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 5

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data + 8) >>> ((in_data - 7) & ((in_data ^ 5) >>> 8)));
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 | 6) <<< ((data_0 <<< 10) + 5)) + 9);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 | 5) & (((data_1 & 3) - (data_1 - 6)) ^ (data_1 >>> 1)));
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 & 5) + 10);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((((data_3 <<< 5) & 1) + 3) >>> ((data_3 >>> 3) - 2));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_4, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_256-opd_3-1,"`define WIDTH 256
`define DEPTH 8

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 10) & ((in_data - 7) & ((in_data ^ 8) >>> (in_data ^ 3))));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] ^ 4) <<< (data[i] >>> 7));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 9) <<< (in_data <<< 10)) ^ 9);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data - 4) ^ 4) | 1);
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 7) ^ 2) | 4);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 8

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data >>> 9) <<< (in_data <<< 10)) ^ 9);
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 - 4) ^ 4) | 1);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 ^ 4) <<< (data_1 >>> 7));
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 ^ 4) <<< (data_2 >>> 7));
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 ^ 4) <<< (data_3 >>> 7));
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 ^ 4) <<< (data_4 >>> 7));
    wire [WIDTH-1:0] data_6;
    assign data_6 = (((data_5 + 7) ^ 2) | 4);
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((data_6 & 10) & ((data_6 - 7) & ((data_6 ^ 8) >>> (data_6 ^ 3))));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_7, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_256-opd_4-0,"`define WIDTH 256
`define DEPTH 5

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data <<< 3) - (in_data ^ 1)) + 4) ^ 1);
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data >>> 2) | (in_data + 3)) + 2) >>> ((((in_data & 2) + (in_data | 6)) | (in_data ^ 5)) + 6));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data - 8) >>> 5) >>> (in_data + 10)) + 9);
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 5) ^ 8);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 5) >>> (in_data - 10)) ^ (((in_data <<< 1) - ((in_data <<< 7) ^ (in_data & 10))) >>> 5));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 5

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data >>> 5) >>> (in_data - 10)) ^ (((in_data <<< 1) - ((in_data <<< 7) ^ (in_data & 10))) >>> 5));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((((data_0 - 8) >>> 5) >>> (data_0 + 10)) + 9);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((((data_1 <<< 3) - (data_1 ^ 1)) + 4) ^ 1);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((((data_2 >>> 2) | (data_2 + 3)) + 2) >>> ((((data_2 & 2) + (data_2 | 6)) | (data_2 ^ 5)) + 6));
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 >>> 5) ^ 8);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_4, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_5-w_256-opd_4-1,"`define WIDTH 256
`define DEPTH 5

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data <<< 7) ^ 6) >>> 3);
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((((in_data ^ 6) ^ (in_data ^ 10)) | 4) | 4) ^ 6);
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 4) - (((in_data ^ 1) | 10) | ((in_data >>> 6) <<< 3)));
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data >>> 2) & 1) ^ (((in_data & 3) ^ 5) + 8)) ^ (in_data <<< 3));
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 1) ^ ((in_data & 9) ^ (in_data | 2))) + 1);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 5

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((((in_data >>> 2) & 1) ^ (((in_data & 3) ^ 5) + 8)) ^ (in_data <<< 3));
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 <<< 7) ^ 6) >>> 3);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 & 4) - (((data_1 ^ 1) | 10) | ((data_1 >>> 6) <<< 3)));
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 | 1) ^ ((data_2 & 9) ^ (data_2 | 2))) + 1);
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((((data_3 ^ 6) ^ (data_3 ^ 10)) | 4) | 4) ^ 6);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_4, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_128-opd_2-0,"`define WIDTH 128
`define DEPTH 15

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 8) + (in_data <<< 8));
        end
    end
endmodule

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data - 3) | (in_data ^ 9));
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 2) >>> (in_data <<< 10));
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] ^ 6) <<< 4);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data - 5) & (in_data ^ 6));
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 7) ^ 5) ^ 3);
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data ^ 3) <<< (in_data - 3)) | 10);
        end
    end
endmodule

module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data <<< 9) & (in_data | 6)) & (in_data | 9));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] <<< 7) <<< 1);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 9) - (in_data & 6));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[10]), 
        .out_vld(ready[10])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[10]),
        .in_vld(ready[10]),
        .out_data(data[11]), 
        .out_vld(ready[11])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[11]),
        .in_vld(ready[11]),
        .out_data(data[12]), 
        .out_vld(ready[12])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[12]),
        .in_vld(ready[12]),
        .out_data(data[13]), 
        .out_vld(ready[13])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[13]),
        .in_vld(ready[13]),
        .out_data(data[14]), 
        .out_vld(ready[14])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[14]),
        .in_vld(ready[14]),
        .out_data(data[15]), 
        .out_vld(ready[15])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 15

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data >>> 9) - (in_data & 6));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 - 5) & (data_0 ^ 6));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 <<< 7) <<< 1);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 <<< 7) <<< 1);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 <<< 7) <<< 1);
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 <<< 7) <<< 1);
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((data_5 ^ 6) <<< 4);
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((data_6 ^ 6) <<< 4);
    wire [WIDTH-1:0] data_8;
    assign data_8 = ((data_7 ^ 6) <<< 4);
    wire [WIDTH-1:0] data_9;
    assign data_9 = (((data_8 ^ 3) <<< (data_8 - 3)) | 10);
    wire [WIDTH-1:0] data_10;
    assign data_10 = (((data_9 + 7) ^ 5) ^ 3);
    wire [WIDTH-1:0] data_11;
    assign data_11 = (((data_10 <<< 9) & (data_10 | 6)) & (data_10 | 9));
    wire [WIDTH-1:0] data_12;
    assign data_12 = ((data_11 - 3) | (data_11 ^ 9));
    wire [WIDTH-1:0] data_13;
    assign data_13 = ((data_12 ^ 2) >>> (data_12 <<< 10));
    wire [WIDTH-1:0] data_14;
    assign data_14 = ((data_13 >>> 8) + (data_13 <<< 8));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_14, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_128-opd_2-1,"`define WIDTH 128
`define DEPTH 17

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 7) >>> 3) & (in_data >>> 10));
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] - 2) ^ 7);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data <<< 6) & 9) ^ 3);
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data - 4) >>> (in_data & 5)) <<< ((in_data & 2) | (in_data ^ 7)));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 6) <<< 7);
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] + 2) >>> 10);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data & 2) >>> 5) & ((in_data & 8) & (in_data <<< 7)));
        end
    end
endmodule

module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] >>> 6) & 4) & 7);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 10) | (in_data | 9));
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 9) | 1);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[8]),
        .in_vld(ready[8]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[10]), 
        .out_vld(ready[10])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[10]),
        .in_vld(ready[10]),
        .out_data(data[14]), 
        .out_vld(ready[14])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[14]),
        .in_vld(ready[14]),
        .out_data(data[15]), 
        .out_vld(ready[15])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[15]),
        .in_vld(ready[15]),
        .out_data(data[16]), 
        .out_vld(ready[16])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[16]),
        .in_vld(ready[16]),
        .out_data(data[17]), 
        .out_vld(ready[17])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 17

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data >>> 9) | 1);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 ^ 6) <<< 7);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 + 2) >>> 10);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 + 2) >>> 10);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 - 2) ^ 7);
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 - 2) ^ 7);
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((data_5 - 2) ^ 7);
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((data_6 - 2) ^ 7);
    wire [WIDTH-1:0] data_8;
    assign data_8 = (((data_7 + 7) >>> 3) & (data_7 >>> 10));
    wire [WIDTH-1:0] data_9;
    assign data_9 = (((data_8 - 4) >>> (data_8 & 5)) <<< ((data_8 & 2) | (data_8 ^ 7)));
    wire [WIDTH-1:0] data_10;
    assign data_10 = (((data_9 >>> 6) & 4) & 7);
    wire [WIDTH-1:0] data_11;
    assign data_11 = (((data_10 >>> 6) & 4) & 7);
    wire [WIDTH-1:0] data_12;
    assign data_12 = (((data_11 >>> 6) & 4) & 7);
    wire [WIDTH-1:0] data_13;
    assign data_13 = (((data_12 >>> 6) & 4) & 7);
    wire [WIDTH-1:0] data_14;
    assign data_14 = (((data_13 <<< 6) & 9) ^ 3);
    wire [WIDTH-1:0] data_15;
    assign data_15 = (((data_14 & 2) >>> 5) & ((data_14 & 8) & (data_14 <<< 7)));
    wire [WIDTH-1:0] data_16;
    assign data_16 = ((data_15 ^ 10) | (data_15 | 9));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_16, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_128-opd_3-0,"`define WIDTH 128
`define DEPTH 12

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data & 1) - 7) | 7);
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] - 10) <<< ((data[i] ^ 4) - (data[i] + 3))) ^ 10);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 2) <<< 3) <<< ((in_data | 4) <<< (in_data <<< 6)));
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 8) <<< ((in_data | 5) - 5));
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 4) ^ (in_data >>> 7)) - 7);
        end
    end
endmodule

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data & 9) | (in_data & 3)) <<< 4) >>> 3);
        end
    end
endmodule

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data & 6) >>> (in_data - 3)) >>> (((in_data - 4) <<< 6) >>> 6));
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] - 8) | 2) ^ 9);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data + 6) ^ 2) >>> 9) | 10);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 7) | (in_data - 4));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[8]),
        .in_vld(ready[8]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[11]), 
        .out_vld(ready[11])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[11]),
        .in_vld(ready[11]),
        .out_data(data[12]), 
        .out_vld(ready[12])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 12

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data ^ 7) | (in_data - 4));
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 & 1) - 7) | 7);
    wire [WIDTH-1:0] data_2;
    assign data_2 = (((data_1 + 2) <<< 3) <<< ((data_1 | 4) <<< (data_1 <<< 6)));
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 - 8) | 2) ^ 9);
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 - 8) | 2) ^ 9);
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((data_4 | 4) ^ (data_4 >>> 7)) - 7);
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((data_5 >>> 8) <<< ((data_5 | 5) - 5));
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((((data_6 + 6) ^ 2) >>> 9) | 10);
    wire [WIDTH-1:0] data_8;
    assign data_8 = ((((data_7 & 9) | (data_7 & 3)) <<< 4) >>> 3);
    wire [WIDTH-1:0] data_9;
    assign data_9 = (((data_8 - 10) <<< ((data_8 ^ 4) - (data_8 + 3))) ^ 10);
    wire [WIDTH-1:0] data_10;
    assign data_10 = (((data_9 - 10) <<< ((data_9 ^ 4) - (data_9 + 3))) ^ 10);
    wire [WIDTH-1:0] data_11;
    assign data_11 = (((data_10 & 6) >>> (data_10 - 3)) >>> (((data_10 - 4) <<< 6) >>> 6));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_11, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_128-opd_3-1,"`define WIDTH 128
`define DEPTH 16

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] >>> 7) & (((data[i] + 1) - 7) ^ 8));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data + 10) >>> 2);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] ^ 8) ^ 6);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data - 4) + 9) + 9);
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 4) - 3) | (((in_data >>> 9) & 10) & 5));
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 1) <<< 1) | 10);
        end
    end
endmodule

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data <<< 1) >>> 6) & 9) ^ 8);
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data ^ 7) - 6) | 1) & 9);
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 1) & 4) >>> ((in_data ^ 8) <<< 10));
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] & 1) >>> ((data[i] & 4) + 5));
                end
            end
        end
    endgenerate
endmodule



module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[8]),
        .in_vld(ready[8]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[10]), 
        .out_vld(ready[10])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[10]),
        .in_vld(ready[10]),
        .out_data(data[11]), 
        .out_vld(ready[11])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[11]),
        .in_vld(ready[11]),
        .out_data(data[14]), 
        .out_vld(ready[14])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[14]),
        .in_vld(ready[14]),
        .out_data(data[16]), 
        .out_vld(ready[16])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 16

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data >>> 1) <<< 1) | 10);
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 ^ 8) ^ 6);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 ^ 8) ^ 6);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 ^ 8) ^ 6);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 ^ 8) ^ 6);
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((data_4 + 1) & 4) >>> ((data_4 ^ 8) <<< 10));
    wire [WIDTH-1:0] data_6;
    assign data_6 = (((data_5 | 4) - 3) | (((data_5 >>> 9) & 10) & 5));
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((((data_6 ^ 7) - 6) | 1) & 9);
    wire [WIDTH-1:0] data_8;
    assign data_8 = ((data_7 + 10) >>> 2);
    wire [WIDTH-1:0] data_9;
    assign data_9 = (((data_8 - 4) + 9) + 9);
    wire [WIDTH-1:0] data_10;
    assign data_10 = ((((data_9 <<< 1) >>> 6) & 9) ^ 8);
    wire [WIDTH-1:0] data_11;
    assign data_11 = ((data_10 & 1) >>> ((data_10 & 4) + 5));
    wire [WIDTH-1:0] data_12;
    assign data_12 = ((data_11 & 1) >>> ((data_11 & 4) + 5));
    wire [WIDTH-1:0] data_13;
    assign data_13 = ((data_12 & 1) >>> ((data_12 & 4) + 5));
    wire [WIDTH-1:0] data_14;
    assign data_14 = ((data_13 >>> 7) & (((data_13 + 1) - 7) ^ 8));
    wire [WIDTH-1:0] data_15;
    assign data_15 = ((data_14 >>> 7) & (((data_14 + 1) - 7) ^ 8));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_15, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_128-opd_4-0,"`define WIDTH 128
`define DEPTH 17

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data - 10) & 3) & 4) >>> ((in_data - 1) | ((in_data - 9) ^ (in_data & 6))));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 1) - 8) >>> 6);
        end
    end
endmodule

module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data ^ 5) | ((in_data - 5) >>> 10)) <<< (((in_data & 5) ^ (in_data | 9)) ^ ((in_data + 1) <<< 4))) - (((in_data - 6) >>> 4) + (((in_data >>> 5) + 10) & ((in_data >>> 6) - (in_data | 2)))));
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data <<< 3) >>> 2) >>> 1) + (in_data ^ 5));
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data >>> 4) + (in_data & 8)) & 9) - 6);
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((((data[i] <<< 1) ^ (data[i] >>> 4)) >>> (data[i] - 7)) - 4) - ((((data[i] <<< 7) + (data[i] & 7)) - (data[i] <<< 7)) - 7));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((((data[i] >>> 3) & 5) & (data[i] ^ 5)) - (data[i] | 10)) <<< 10);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] & 9) - 5) >>> 9);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data - 8) + 5);
        end
    end
endmodule

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data - 8) - 2) <<< 3);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[10]), 
        .out_vld(ready[10])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[10]),
        .in_vld(ready[10]),
        .out_data(data[11]), 
        .out_vld(ready[11])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[11]),
        .in_vld(ready[11]),
        .out_data(data[12]), 
        .out_vld(ready[12])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[12]),
        .in_vld(ready[12]),
        .out_data(data[13]), 
        .out_vld(ready[13])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[13]),
        .in_vld(ready[13]),
        .out_data(data[16]), 
        .out_vld(ready[16])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[16]),
        .in_vld(ready[16]),
        .out_data(data[17]), 
        .out_vld(ready[17])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 17

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data - 8) + 5);
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 | 1) - 8) >>> 6);
    wire [WIDTH-1:0] data_2;
    assign data_2 = (((data_1 & 9) - 5) >>> 9);
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 & 9) - 5) >>> 9);
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 & 9) - 5) >>> 9);
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((((data_4 <<< 1) ^ (data_4 >>> 4)) >>> (data_4 - 7)) - 4) - ((((data_4 <<< 7) + (data_4 & 7)) - (data_4 <<< 7)) - 7));
    wire [WIDTH-1:0] data_6;
    assign data_6 = (((((data_5 <<< 1) ^ (data_5 >>> 4)) >>> (data_5 - 7)) - 4) - ((((data_5 <<< 7) + (data_5 & 7)) - (data_5 <<< 7)) - 7));
    wire [WIDTH-1:0] data_7;
    assign data_7 = (((((data_6 <<< 1) ^ (data_6 >>> 4)) >>> (data_6 - 7)) - 4) - ((((data_6 <<< 7) + (data_6 & 7)) - (data_6 <<< 7)) - 7));
    wire [WIDTH-1:0] data_8;
    assign data_8 = (((((data_7 <<< 1) ^ (data_7 >>> 4)) >>> (data_7 - 7)) - 4) - ((((data_7 <<< 7) + (data_7 & 7)) - (data_7 <<< 7)) - 7));
    wire [WIDTH-1:0] data_9;
    assign data_9 = ((((data_8 <<< 3) >>> 2) >>> 1) + (data_8 ^ 5));
    wire [WIDTH-1:0] data_10;
    assign data_10 = ((((data_9 >>> 4) + (data_9 & 8)) & 9) - 6);
    wire [WIDTH-1:0] data_11;
    assign data_11 = ((((data_10 ^ 5) | ((data_10 - 5) >>> 10)) <<< (((data_10 & 5) ^ (data_10 | 9)) ^ ((data_10 + 1) <<< 4))) - (((data_10 - 6) >>> 4) + (((data_10 >>> 5) + 10) & ((data_10 >>> 6) - (data_10 | 2)))));
    wire [WIDTH-1:0] data_12;
    assign data_12 = ((((data_11 - 10) & 3) & 4) >>> ((data_11 - 1) | ((data_11 - 9) ^ (data_11 & 6))));
    wire [WIDTH-1:0] data_13;
    assign data_13 = (((((data_12 >>> 3) & 5) & (data_12 ^ 5)) - (data_12 | 10)) <<< 10);
    wire [WIDTH-1:0] data_14;
    assign data_14 = (((((data_13 >>> 3) & 5) & (data_13 ^ 5)) - (data_13 | 10)) <<< 10);
    wire [WIDTH-1:0] data_15;
    assign data_15 = (((((data_14 >>> 3) & 5) & (data_14 ^ 5)) - (data_14 | 10)) <<< 10);
    wire [WIDTH-1:0] data_16;
    assign data_16 = (((data_15 - 8) - 2) <<< 3);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_16, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_128-opd_4-1,"`define WIDTH 128
`define DEPTH 16

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 5) >>> (in_data - 9)) & (in_data + 6));
        end
    end
endmodule

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 7) ^ 5);
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] >>> 2) >>> 6);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] <<< 10) <<< ((data[i] | 6) & 4)) + 9);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((((data[i] | 9) <<< (data[i] - 7)) <<< (data[i] <<< 10)) | ((data[i] <<< 3) + (data[i] & 10))) | ((data[i] - 9) | (data[i] - 6)));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 9) <<< (((in_data + 10) - 4) >>> 8));
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((((data[i] | 4) ^ 4) | (data[i] & 9)) ^ (((data[i] ^ 8) - 4) >>> 7));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data ^ 7) | (in_data - 3)) | 9) - ((in_data - 3) >>> (in_data <<< 10)));
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data + 10) ^ 1) + (in_data & 3)) ^ 1);
        end
    end
endmodule

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data - 5) & 10) ^ 6) - 4);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[10]), 
        .out_vld(ready[10])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[10]),
        .in_vld(ready[10]),
        .out_data(data[12]), 
        .out_vld(ready[12])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[12]),
        .in_vld(ready[12]),
        .out_data(data[13]), 
        .out_vld(ready[13])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[13]),
        .in_vld(ready[13]),
        .out_data(data[15]), 
        .out_vld(ready[15])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[15]),
        .in_vld(ready[15]),
        .out_data(data[16]), 
        .out_vld(ready[16])
    );
endmodule",,"`define WIDTH 128
`define DEPTH 16

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data >>> 9) <<< (((in_data + 10) - 4) >>> 8));
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 + 5) >>> (data_0 - 9)) & (data_0 + 6));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 >>> 2) >>> 6);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 >>> 2) >>> 6);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 >>> 2) >>> 6);
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 >>> 2) >>> 6);
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((((data_5 ^ 7) | (data_5 - 3)) | 9) - ((data_5 - 3) >>> (data_5 <<< 10)));
    wire [WIDTH-1:0] data_7;
    assign data_7 = (((data_6 <<< 10) <<< ((data_6 | 6) & 4)) + 9);
    wire [WIDTH-1:0] data_8;
    assign data_8 = (((data_7 <<< 10) <<< ((data_7 | 6) & 4)) + 9);
    wire [WIDTH-1:0] data_9;
    assign data_9 = ((((data_8 + 10) ^ 1) + (data_8 & 3)) ^ 1);
    wire [WIDTH-1:0] data_10;
    assign data_10 = (((((data_9 | 9) <<< (data_9 - 7)) <<< (data_9 <<< 10)) | ((data_9 <<< 3) + (data_9 & 10))) | ((data_9 - 9) | (data_9 - 6)));
    wire [WIDTH-1:0] data_11;
    assign data_11 = (((((data_10 | 9) <<< (data_10 - 7)) <<< (data_10 <<< 10)) | ((data_10 <<< 3) + (data_10 & 10))) | ((data_10 - 9) | (data_10 - 6)));
    wire [WIDTH-1:0] data_12;
    assign data_12 = ((((data_11 - 5) & 10) ^ 6) - 4);
    wire [WIDTH-1:0] data_13;
    assign data_13 = ((((data_12 | 4) ^ 4) | (data_12 & 9)) ^ (((data_12 ^ 8) - 4) >>> 7));
    wire [WIDTH-1:0] data_14;
    assign data_14 = ((((data_13 | 4) ^ 4) | (data_13 & 9)) ^ (((data_13 ^ 8) - 4) >>> 7));
    wire [WIDTH-1:0] data_15;
    assign data_15 = ((data_14 & 7) ^ 5);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_15, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_256-opd_2-0,"`define WIDTH 256
`define DEPTH 21

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] <<< 5) ^ ((data[i] >>> 10) <<< (data[i] + 3)));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 8) <<< 5);
        end
    end
endmodule

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] & 10) - (data[i] >>> 10)) & 7);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 10) >>> 7) ^ 5);
        end
    end
endmodule

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] & 5) ^ (data[i] - 10)) | ((data[i] >>> 5) - 3));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 3) + (in_data <<< 9)) | ((in_data & 7) >>> 3));
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data + 9) - ((in_data - 4) ^ 8));
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] - 3) - (data[i] <<< 8)) <<< 10);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 4) ^ 4) ^ (in_data + 9));
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 7) ^ 10);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[13]), 
        .out_vld(ready[13])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[13]),
        .in_vld(ready[13]),
        .out_data(data[14]), 
        .out_vld(ready[14])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[14]),
        .in_vld(ready[14]),
        .out_data(data[15]), 
        .out_vld(ready[15])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[15]),
        .in_vld(ready[15]),
        .out_data(data[16]), 
        .out_vld(ready[16])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[16]),
        .in_vld(ready[16]),
        .out_data(data[19]), 
        .out_vld(ready[19])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[19]),
        .in_vld(ready[19]),
        .out_data(data[20]), 
        .out_vld(ready[20])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[20]),
        .in_vld(ready[20]),
        .out_data(data[21]), 
        .out_vld(ready[21])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 21

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data & 5) ^ (in_data - 10)) | ((in_data >>> 5) - 3));
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((data_0 & 5) ^ (data_0 - 10)) | ((data_0 >>> 5) - 3));
    wire [WIDTH-1:0] data_2;
    assign data_2 = (((data_1 & 5) ^ (data_1 - 10)) | ((data_1 >>> 5) - 3));
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 & 5) ^ (data_2 - 10)) | ((data_2 >>> 5) - 3));
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 >>> 10) >>> 7) ^ 5);
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 <<< 5) ^ ((data_4 >>> 10) <<< (data_4 + 3)));
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((data_5 <<< 5) ^ ((data_5 >>> 10) <<< (data_5 + 3)));
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((data_6 <<< 5) ^ ((data_6 >>> 10) <<< (data_6 + 3)));
    wire [WIDTH-1:0] data_8;
    assign data_8 = ((data_7 <<< 5) ^ ((data_7 >>> 10) <<< (data_7 + 3)));
    wire [WIDTH-1:0] data_9;
    assign data_9 = (((data_8 - 3) - (data_8 <<< 8)) <<< 10);
    wire [WIDTH-1:0] data_10;
    assign data_10 = (((data_9 - 3) - (data_9 <<< 8)) <<< 10);
    wire [WIDTH-1:0] data_11;
    assign data_11 = (((data_10 - 3) - (data_10 <<< 8)) <<< 10);
    wire [WIDTH-1:0] data_12;
    assign data_12 = (((data_11 - 3) - (data_11 <<< 8)) <<< 10);
    wire [WIDTH-1:0] data_13;
    assign data_13 = ((data_12 & 8) <<< 5);
    wire [WIDTH-1:0] data_14;
    assign data_14 = ((data_13 ^ 7) ^ 10);
    wire [WIDTH-1:0] data_15;
    assign data_15 = (((data_14 | 3) + (data_14 <<< 9)) | ((data_14 & 7) >>> 3));
    wire [WIDTH-1:0] data_16;
    assign data_16 = (((data_15 & 10) - (data_15 >>> 10)) & 7);
    wire [WIDTH-1:0] data_17;
    assign data_17 = (((data_16 & 10) - (data_16 >>> 10)) & 7);
    wire [WIDTH-1:0] data_18;
    assign data_18 = (((data_17 & 10) - (data_17 >>> 10)) & 7);
    wire [WIDTH-1:0] data_19;
    assign data_19 = ((data_18 + 9) - ((data_18 - 4) ^ 8));
    wire [WIDTH-1:0] data_20;
    assign data_20 = (((data_19 + 4) ^ 4) ^ (data_19 + 9));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_20, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_256-opd_2-1,"`define WIDTH 256
`define DEPTH 17

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 10) + (in_data ^ 7));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 4) & 6);
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 9) <<< 4);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 3) - 9);
        end
    end
endmodule

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] ^ 10) >>> (data[i] + 5)) - ((data[i] | 1) ^ 8));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 3) & 10) <<< (in_data - 1));
        end
    end
endmodule

module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] | 4) + 6) - 1);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] <<< 9) <<< (data[i] | 4));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 7) & (in_data - 8));
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 6) <<< (in_data - 10));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[10]), 
        .out_vld(ready[10])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[10]),
        .in_vld(ready[10]),
        .out_data(data[14]), 
        .out_vld(ready[14])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[14]),
        .in_vld(ready[14]),
        .out_data(data[17]), 
        .out_vld(ready[17])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 17

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data >>> 3) & 10) <<< (in_data - 1));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 <<< 3) - 9);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((data_1 >>> 4) & 6);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 <<< 7) & (data_2 - 8));
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 | 6) <<< (data_3 - 10));
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 | 9) <<< 4);
    wire [WIDTH-1:0] data_6;
    assign data_6 = (((data_5 | 4) + 6) - 1);
    wire [WIDTH-1:0] data_7;
    assign data_7 = (((data_6 | 4) + 6) - 1);
    wire [WIDTH-1:0] data_8;
    assign data_8 = (((data_7 | 4) + 6) - 1);
    wire [WIDTH-1:0] data_9;
    assign data_9 = ((data_8 <<< 10) + (data_8 ^ 7));
    wire [WIDTH-1:0] data_10;
    assign data_10 = ((data_9 <<< 9) <<< (data_9 | 4));
    wire [WIDTH-1:0] data_11;
    assign data_11 = ((data_10 <<< 9) <<< (data_10 | 4));
    wire [WIDTH-1:0] data_12;
    assign data_12 = ((data_11 <<< 9) <<< (data_11 | 4));
    wire [WIDTH-1:0] data_13;
    assign data_13 = ((data_12 <<< 9) <<< (data_12 | 4));
    wire [WIDTH-1:0] data_14;
    assign data_14 = (((data_13 ^ 10) >>> (data_13 + 5)) - ((data_13 | 1) ^ 8));
    wire [WIDTH-1:0] data_15;
    assign data_15 = (((data_14 ^ 10) >>> (data_14 + 5)) - ((data_14 | 1) ^ 8));
    wire [WIDTH-1:0] data_16;
    assign data_16 = (((data_15 ^ 10) >>> (data_15 + 5)) - ((data_15 | 1) ^ 8));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_16, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_256-opd_3-0,"`define WIDTH 256
`define DEPTH 13

module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data >>> 5) & 4) - (in_data - 8));
        end
    end
endmodule

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data + 5) + (in_data >>> 7)) >>> (in_data <<< 7));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((((data[i] >>> 1) ^ 10) & 9) <<< ((data[i] | 5) >>> 7));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] - 1) - (((data[i] | 3) & 10) & 2));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data - 4) + 6) <<< 6);
        end
    end
endmodule

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 7) <<< (in_data + 2));
        end
    end
endmodule

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 8) + ((in_data & 10) >>> 6));
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 2) - (((in_data - 8) >>> 2) ^ 5));
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data & 10) <<< (in_data & 9));
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data | 4) + 9) + 9);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[3]), 
        .out_vld(ready[3])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[3]),
        .in_vld(ready[3]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[8]),
        .in_vld(ready[8]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[10]), 
        .out_vld(ready[10])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[10]),
        .in_vld(ready[10]),
        .out_data(data[11]), 
        .out_vld(ready[11])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[11]),
        .in_vld(ready[11]),
        .out_data(data[12]), 
        .out_vld(ready[12])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[12]),
        .in_vld(ready[12]),
        .out_data(data[13]), 
        .out_vld(ready[13])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 13

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = (((in_data >>> 5) & 4) - (in_data - 8));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((((data_0 >>> 1) ^ 10) & 9) <<< ((data_0 | 5) >>> 7));
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((((data_1 >>> 1) ^ 10) & 9) <<< ((data_1 | 5) >>> 7));
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((data_2 - 1) - (((data_2 | 3) & 10) & 2));
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 - 1) - (((data_3 | 3) & 10) & 2));
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 - 1) - (((data_4 | 3) & 10) & 2));
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((data_5 | 8) + ((data_5 & 10) >>> 6));
    wire [WIDTH-1:0] data_7;
    assign data_7 = (((data_6 | 4) + 9) + 9);
    wire [WIDTH-1:0] data_8;
    assign data_8 = ((data_7 & 10) <<< (data_7 & 9));
    wire [WIDTH-1:0] data_9;
    assign data_9 = (((data_8 - 4) + 6) <<< 6);
    wire [WIDTH-1:0] data_10;
    assign data_10 = ((data_9 | 7) <<< (data_9 + 2));
    wire [WIDTH-1:0] data_11;
    assign data_11 = ((data_10 & 2) - (((data_10 - 8) >>> 2) ^ 5));
    wire [WIDTH-1:0] data_12;
    assign data_12 = (((data_11 + 5) + (data_11 >>> 7)) >>> (data_11 <<< 7));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_12, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_256-opd_3-1,"`define WIDTH 256
`define DEPTH 19

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] | 1) ^ 7) - (((data[i] >>> 7) ^ (data[i] ^ 5)) <<< 6));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data ^ 6) >>> 10) <<< 7) | 5);
        end
    end
endmodule

module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data <<< 5) + ((in_data | 2) + 10)) ^ 1);
        end
    end
endmodule

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] <<< 9) | 2) + ((data[i] <<< 2) + (data[i] + 8)));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data + 10) + 4) + 7) >>> 10);
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] - 10) - (data[i] <<< 3));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((data[i] ^ 3) - ((data[i] & 1) | (data[i] - 2)));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 4) + (in_data | 9));
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] + 7) <<< 5) <<< ((data[i] + 1) >>> 2));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data | 8) ^ 7);
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[2]), 
        .out_vld(ready[2])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[2]),
        .in_vld(ready[2]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[7]), 
        .out_vld(ready[7])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[7]),
        .in_vld(ready[7]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[8]),
        .in_vld(ready[8]),
        .out_data(data[12]), 
        .out_vld(ready[12])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[12]),
        .in_vld(ready[12]),
        .out_data(data[13]), 
        .out_vld(ready[13])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[13]),
        .in_vld(ready[13]),
        .out_data(data[14]), 
        .out_vld(ready[14])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[14]),
        .in_vld(ready[14]),
        .out_data(data[17]), 
        .out_vld(ready[17])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[17]),
        .in_vld(ready[17]),
        .out_data(data[19]), 
        .out_vld(ready[19])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 19

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data ^ 3) - ((in_data & 1) | (in_data - 2)));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((data_0 ^ 3) - ((data_0 & 1) | (data_0 - 2)));
    wire [WIDTH-1:0] data_2;
    assign data_2 = (((data_1 | 1) ^ 7) - (((data_1 >>> 7) ^ (data_1 ^ 5)) <<< 6));
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((data_2 | 1) ^ 7) - (((data_2 >>> 7) ^ (data_2 ^ 5)) <<< 6));
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 | 1) ^ 7) - (((data_3 >>> 7) ^ (data_3 ^ 5)) <<< 6));
    wire [WIDTH-1:0] data_5;
    assign data_5 = ((data_4 | 4) + (data_4 | 9));
    wire [WIDTH-1:0] data_6;
    assign data_6 = ((((data_5 ^ 6) >>> 10) <<< 7) | 5);
    wire [WIDTH-1:0] data_7;
    assign data_7 = ((((data_6 + 10) + 4) + 7) >>> 10);
    wire [WIDTH-1:0] data_8;
    assign data_8 = ((data_7 - 10) - (data_7 <<< 3));
    wire [WIDTH-1:0] data_9;
    assign data_9 = ((data_8 - 10) - (data_8 <<< 3));
    wire [WIDTH-1:0] data_10;
    assign data_10 = ((data_9 - 10) - (data_9 <<< 3));
    wire [WIDTH-1:0] data_11;
    assign data_11 = ((data_10 - 10) - (data_10 <<< 3));
    wire [WIDTH-1:0] data_12;
    assign data_12 = ((data_11 | 8) ^ 7);
    wire [WIDTH-1:0] data_13;
    assign data_13 = (((data_12 <<< 5) + ((data_12 | 2) + 10)) ^ 1);
    wire [WIDTH-1:0] data_14;
    assign data_14 = (((data_13 + 7) <<< 5) <<< ((data_13 + 1) >>> 2));
    wire [WIDTH-1:0] data_15;
    assign data_15 = (((data_14 + 7) <<< 5) <<< ((data_14 + 1) >>> 2));
    wire [WIDTH-1:0] data_16;
    assign data_16 = (((data_15 + 7) <<< 5) <<< ((data_15 + 1) >>> 2));
    wire [WIDTH-1:0] data_17;
    assign data_17 = (((data_16 <<< 9) | 2) + ((data_16 <<< 2) + (data_16 + 8)));
    wire [WIDTH-1:0] data_18;
    assign data_18 = (((data_17 <<< 9) | 2) + ((data_17 <<< 2) + (data_17 + 8)));

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_18, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_256-opd_4-0,"`define WIDTH 256
`define DEPTH 19

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] & 1) - 10) >>> 9);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data ^ 6) >>> ((in_data - 3) + (((in_data - 6) & (in_data & 4)) >>> ((in_data & 6) + 9))));
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data <<< 4) <<< 7) | 7);
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 3) <<< 3);
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data & 4) & 3) | (in_data | 8)) - (in_data ^ 1));
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((((data[i] & 4) >>> 7) >>> ((data[i] - 5) >>> ((data[i] + 5) & (data[i] >>> 3)))) + 10);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 4;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= ((((data[i] | 9) + ((data[i] & 6) ^ (data[i] >>> 1))) | (((data[i] >>> 4) <<< 7) - 8)) + 10);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((in_data & 1) & ((in_data & 10) + 10)) | 10);
        end
    end
endmodule

module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 2;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] | 8) <<< (data[i] ^ 6)) - 5);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data | 9) & (in_data >>> 5)) | 9) <<< (((in_data ^ 8) ^ ((in_data - 5) >>> (in_data - 2))) + (((in_data - 8) | (in_data >>> 5)) ^ (in_data <<< 9))));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[8]), 
        .out_vld(ready[8])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[8]),
        .in_vld(ready[8]),
        .out_data(data[12]), 
        .out_vld(ready[12])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[12]),
        .in_vld(ready[12]),
        .out_data(data[13]), 
        .out_vld(ready[13])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[13]),
        .in_vld(ready[13]),
        .out_data(data[14]), 
        .out_vld(ready[14])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[14]),
        .in_vld(ready[14]),
        .out_data(data[16]), 
        .out_vld(ready[16])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[16]),
        .in_vld(ready[16]),
        .out_data(data[17]), 
        .out_vld(ready[17])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[17]),
        .in_vld(ready[17]),
        .out_data(data[18]), 
        .out_vld(ready[18])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[18]),
        .in_vld(ready[18]),
        .out_data(data[19]), 
        .out_vld(ready[19])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 19

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data ^ 6) >>> ((in_data - 3) + (((in_data - 6) & (in_data & 4)) >>> ((in_data & 6) + 9))));
    wire [WIDTH-1:0] data_1;
    assign data_1 = ((((data_0 & 4) >>> 7) >>> ((data_0 - 5) >>> ((data_0 + 5) & (data_0 >>> 3)))) + 10);
    wire [WIDTH-1:0] data_2;
    assign data_2 = ((((data_1 & 4) >>> 7) >>> ((data_1 - 5) >>> ((data_1 + 5) & (data_1 >>> 3)))) + 10);
    wire [WIDTH-1:0] data_3;
    assign data_3 = ((((data_2 & 4) >>> 7) >>> ((data_2 - 5) >>> ((data_2 + 5) & (data_2 >>> 3)))) + 10);
    wire [WIDTH-1:0] data_4;
    assign data_4 = (((data_3 & 1) - 10) >>> 9);
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((data_4 & 1) - 10) >>> 9);
    wire [WIDTH-1:0] data_6;
    assign data_6 = (((data_5 & 1) - 10) >>> 9);
    wire [WIDTH-1:0] data_7;
    assign data_7 = (((data_6 & 1) - 10) >>> 9);
    wire [WIDTH-1:0] data_8;
    assign data_8 = ((((data_7 | 9) + ((data_7 & 6) ^ (data_7 >>> 1))) | (((data_7 >>> 4) <<< 7) - 8)) + 10);
    wire [WIDTH-1:0] data_9;
    assign data_9 = ((((data_8 | 9) + ((data_8 & 6) ^ (data_8 >>> 1))) | (((data_8 >>> 4) <<< 7) - 8)) + 10);
    wire [WIDTH-1:0] data_10;
    assign data_10 = ((((data_9 | 9) + ((data_9 & 6) ^ (data_9 >>> 1))) | (((data_9 >>> 4) <<< 7) - 8)) + 10);
    wire [WIDTH-1:0] data_11;
    assign data_11 = ((((data_10 | 9) + ((data_10 & 6) ^ (data_10 >>> 1))) | (((data_10 >>> 4) <<< 7) - 8)) + 10);
    wire [WIDTH-1:0] data_12;
    assign data_12 = (((data_11 <<< 4) <<< 7) | 7);
    wire [WIDTH-1:0] data_13;
    assign data_13 = ((data_12 <<< 3) <<< 3);
    wire [WIDTH-1:0] data_14;
    assign data_14 = (((data_13 | 8) <<< (data_13 ^ 6)) - 5);
    wire [WIDTH-1:0] data_15;
    assign data_15 = (((data_14 | 8) <<< (data_14 ^ 6)) - 5);
    wire [WIDTH-1:0] data_16;
    assign data_16 = ((((data_15 | 9) & (data_15 >>> 5)) | 9) <<< (((data_15 ^ 8) ^ ((data_15 - 5) >>> (data_15 - 2))) + (((data_15 - 8) | (data_15 >>> 5)) ^ (data_15 <<< 9))));
    wire [WIDTH-1:0] data_17;
    assign data_17 = ((((data_16 & 4) & 3) | (data_16 | 8)) - (data_16 ^ 1));
    wire [WIDTH-1:0] data_18;
    assign data_18 = (((data_17 & 1) & ((data_17 & 10) + 10)) | 10);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_18, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
pipeline_single,ns_10-w_256-opd_4-1,"`define WIDTH 256
`define DEPTH 14

module exec_unit_3 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((((in_data <<< 5) >>> (in_data <<< 3)) + ((in_data - 2) | 5)) ^ ((in_data <<< 2) ^ 6)) + ((in_data & 3) | 5));
        end
    end
endmodule

module exec_unit_2 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data - 3) <<< 2);
        end
    end
endmodule

module exec_unit_4 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((data[i] & 3) | 2) - ((((data[i] <<< 10) ^ 5) & (data[i] & 4)) ^ 9));
                end
            end
        end
    endgenerate
endmodule


module exec_unit_7 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= (((((in_data | 9) <<< 3) - (in_data & 7)) + 1) >>> (((in_data >>> 4) + 8) <<< 1));
        end
    end
endmodule

module exec_unit_9 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data >>> 9) - 2);
        end
    end
endmodule

module exec_unit_5 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data >>> 7) ^ (in_data >>> 6)) + (in_data & 8)) <<< 2);
        end
    end
endmodule

module exec_unit_6 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data - 1) <<< 1);
        end
    end
endmodule

module exec_unit_1 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);  
    parameter WIDTH = `WIDTH;
    localparam DEPTH = 3;
    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output [WIDTH-1:0] out_data;
    output out_vld;

    
    logic [DEPTH:0] ready;
    logic [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    generate
        for (genvar i=0; i < DEPTH; i=i+1) begin : gen
            always @(posedge clk) begin
                if (!reset_) begin
                    ready[i+1] <= 'd0;
                    data[i+1] <= 'd0;
                end else begin
                    ready[i+1] <= ready[i];
                    data[i+1] <= (((((data[i] - 2) - 3) + 4) & (data[i] & 2)) & 2);
                end
            end
        end
    endgenerate
endmodule


module exec_unit_0 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((in_data <<< 6) - (in_data <<< 6));
        end
    end
endmodule

module exec_unit_8 (
    clk,
    reset_,
    in_data,
    in_vld,
    out_data,
    out_vld
);
    parameter WIDTH = `WIDTH;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_data;
    input in_vld;
    output reg [WIDTH-1:0] out_data;
    output reg out_vld;

    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            out_vld <= 'd0;
            out_data <= 'd0;
        end else begin
            out_vld <= in_vld;
            out_data <= ((((in_data >>> 5) | 6) & (((in_data >>> 5) <<< (in_data + 4)) & 8)) <<< (((in_data - 3) <<< 3) <<< 8));
        end
    end
endmodule


module pipeline (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;
    
    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    output out_vld;
    output [WIDTH-1:0] out_data;

    wire [DEPTH:0] ready;
    wire [DEPTH:0][WIDTH-1:0] data;
    assign ready[0] = in_vld;
    assign data[0] = in_data;
    assign out_vld = ready[DEPTH];
    assign out_data = data[DEPTH];

    exec_unit_0 #(.WIDTH(WIDTH)) unit_0 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[0]),
        .in_vld(ready[0]),
        .out_data(data[1]), 
        .out_vld(ready[1])
    );

    exec_unit_1 #(.WIDTH(WIDTH)) unit_1 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[1]),
        .in_vld(ready[1]),
        .out_data(data[4]), 
        .out_vld(ready[4])
    );

    exec_unit_2 #(.WIDTH(WIDTH)) unit_2 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[4]),
        .in_vld(ready[4]),
        .out_data(data[5]), 
        .out_vld(ready[5])
    );

    exec_unit_3 #(.WIDTH(WIDTH)) unit_3 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[5]),
        .in_vld(ready[5]),
        .out_data(data[6]), 
        .out_vld(ready[6])
    );

    exec_unit_4 #(.WIDTH(WIDTH)) unit_4 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[6]),
        .in_vld(ready[6]),
        .out_data(data[9]), 
        .out_vld(ready[9])
    );

    exec_unit_5 #(.WIDTH(WIDTH)) unit_5 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[9]),
        .in_vld(ready[9]),
        .out_data(data[10]), 
        .out_vld(ready[10])
    );

    exec_unit_6 #(.WIDTH(WIDTH)) unit_6 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[10]),
        .in_vld(ready[10]),
        .out_data(data[11]), 
        .out_vld(ready[11])
    );

    exec_unit_7 #(.WIDTH(WIDTH)) unit_7 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[11]),
        .in_vld(ready[11]),
        .out_data(data[12]), 
        .out_vld(ready[12])
    );

    exec_unit_8 #(.WIDTH(WIDTH)) unit_8 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[12]),
        .in_vld(ready[12]),
        .out_data(data[13]), 
        .out_vld(ready[13])
    );

    exec_unit_9 #(.WIDTH(WIDTH)) unit_9 (
        .clk(clk),
        .reset_(reset_),
        .in_data(data[13]),
        .in_vld(ready[13]),
        .out_data(data[14]), 
        .out_vld(ready[14])
    );
endmodule",,"`define WIDTH 256
`define DEPTH 14

module pipeline_tb (
    clk,
    reset_,
    in_vld,
    in_data,
    out_vld,
    out_data
);
    parameter WIDTH=`WIDTH;
    parameter DEPTH=`DEPTH;

    input clk;
    input reset_;
    input in_vld;
    input [WIDTH-1:0] in_data;
    input out_vld;
    input [WIDTH-1:0] out_data;

    assign tb_reset = (reset_ == 1'b0);
    wire [WIDTH-1:0] data_0;
    assign data_0 = ((in_data <<< 6) - (in_data <<< 6));
    wire [WIDTH-1:0] data_1;
    assign data_1 = (((((data_0 - 2) - 3) + 4) & (data_0 & 2)) & 2);
    wire [WIDTH-1:0] data_2;
    assign data_2 = (((((data_1 - 2) - 3) + 4) & (data_1 & 2)) & 2);
    wire [WIDTH-1:0] data_3;
    assign data_3 = (((((data_2 - 2) - 3) + 4) & (data_2 & 2)) & 2);
    wire [WIDTH-1:0] data_4;
    assign data_4 = ((data_3 - 3) <<< 2);
    wire [WIDTH-1:0] data_5;
    assign data_5 = (((((data_4 <<< 5) >>> (data_4 <<< 3)) + ((data_4 - 2) | 5)) ^ ((data_4 <<< 2) ^ 6)) + ((data_4 & 3) | 5));
    wire [WIDTH-1:0] data_6;
    assign data_6 = (((data_5 & 3) | 2) - ((((data_5 <<< 10) ^ 5) & (data_5 & 4)) ^ 9));
    wire [WIDTH-1:0] data_7;
    assign data_7 = (((data_6 & 3) | 2) - ((((data_6 <<< 10) ^ 5) & (data_6 & 4)) ^ 9));
    wire [WIDTH-1:0] data_8;
    assign data_8 = (((data_7 & 3) | 2) - ((((data_7 <<< 10) ^ 5) & (data_7 & 4)) ^ 9));
    wire [WIDTH-1:0] data_9;
    assign data_9 = ((((data_8 >>> 7) ^ (data_8 >>> 6)) + (data_8 & 8)) <<< 2);
    wire [WIDTH-1:0] data_10;
    assign data_10 = ((data_9 - 1) <<< 1);
    wire [WIDTH-1:0] data_11;
    assign data_11 = (((((data_10 | 9) <<< 3) - (data_10 & 7)) + 1) >>> (((data_10 >>> 4) + 8) <<< 1));
    wire [WIDTH-1:0] data_12;
    assign data_12 = ((((data_11 >>> 5) | 6) & (((data_11 >>> 5) <<< (data_11 + 4)) & 8)) <<< (((data_11 - 3) <<< 3) <<< 8));
    wire [WIDTH-1:0] data_13;
    assign data_13 = ((data_12 >>> 9) - 2);

    asrt: assert property (@(posedge clk) disable iff(tb_reset)
        in_vld |-> ##DEPTH out_vld && (out_data == $past(data_13, DEPTH))
    );
    
endmodule


bind pipeline pipeline_tb #(
        .WIDTH(`WIDTH),
        .DEPTH(`DEPTH)
    ) pipeline_tb_inst (.*);
"
