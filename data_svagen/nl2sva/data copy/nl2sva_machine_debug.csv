design_name,task_id,prompt,ref_solution,testbench
nl2sva_machine,4_0,"If either sig_C and sig_I are both high, or sig_C is high, the condition is met","assert property(@(posedge clk)
	((sig_C && sig_I) || sig_C)
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,"If sig_J is high, then one cycle later, the condition that the XOR of the complements of sig_G and sig_E is not equal to 1 must hold","assert property(@(posedge clk)
	sig_J |-> ##1 ((!sig_G ^ !sig_E) !== 1'b1)
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,"When sig_B is 1, it must remain unchanged","assert property(@(posedge clk)
	$stable((sig_B === 1'b1))
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,"If sig_F is not equal to 1, then two cycles later, sig_G must be true","assert property(@(posedge clk)
	(sig_F !== 1'b1) |-> ##2 &sig_G
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,"If sig_B is strictly equal to 1'b1, then this is considered true","assert property(@(posedge clk)
	(((sig_B === 1'b1) === 1'b1) === 1'b1)
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,"If sig_G is true, then within the next 1 to 5 cycles, either sig_J does not contain all '1's or sig_H will be true","assert property(@(posedge clk)
	sig_G |=> ##[1:5] ((~&sig_J !== 1'b1) || sig_H)
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,"Whenever sig_G is not exactly 1'b1 is true, it must be exclusive-or (XOR) with either sig_E being true or sig_F containing no '1' bit","assert property(@(posedge clk)
	(((sig_G !== 1'b1) === 1'b1) ^ (sig_E || ~|sig_F))
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,sig_F must have been all zeros two cycles ago,"assert property(@(posedge clk)
	$past(~|sig_F, 2)
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,"If sig_J is true, then after four clock cycles, sig_F must not be true and sig_I must be true","assert property(@(posedge clk)
	(sig_J === 1'b1) |=> ##4 ((sig_F !== 1'b1) && sig_I)
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,4_0,"If the condition where sig_H is less than sig_D implies the negated AND of sig_G holds true, then in the following cycle, either sig_H must be true or sig_F must not equal 1'b1","assert property(@(posedge clk)
	((sig_H < sig_D) <= ~&sig_G) |-> ##1 (sig_H || (sig_F !== 1'b1))
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
