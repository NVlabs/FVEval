design_name,task_id,prompt,ref_solution,testbench
nl2sva_machine,0_0,"If the value of sig_E is less than the result of a bitwise XOR operation between sig_C and the negation of the bitwise OR between sig_H, and this value is equal to the result of the logical equality between the bitwise OR between sig_A and the negation of sig_J, or sig_B, then the assertion is true","assert property(@(posedge clk)
	((sig_E < (sig_B == (sig_C ^ ~|sig_H))) == ((|sig_A === !sig_J) || sig_B))
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,0_1,"If the value of sig_E is less than the comparison between sig_B and the result of sig_C XOR the logical negation of sig_H, and that value is equal to the comparison between the result of sig_A being equal to the logical negation of sig_J and sig_B, then the assertion is true","assert property(@(posedge clk)
	((sig_E < (sig_B == (sig_C ^ ~|sig_H))) == ((|sig_A === !sig_J) || sig_B))
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,0_2,"If the value of sig_E is less than the result of the calculation (sig_B is equal to the bitwise XOR of sig_C and the complement of the bitwise NOR of sig_H), and the result of the comparison between the equality of sig_A and the logical negation of sig_J, or sig_B, is equal to the overall expression, then the assertion is satisfied on the next rising edge of the clock","assert property(@(posedge clk)
	((sig_E < (sig_B == (sig_C ^ ~|sig_H))) == ((|sig_A === !sig_J) || sig_B))
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,0_3,"If the value of sig_E is less than the result of the expression (sig_B equals the bitwise XOR of sig_C and the bitwise negation of the negation of sig_H), which is equal to the result of the expression (sig_A is identical to the bitwise negation of sig_J) or sig_B, then the assertion is true","assert property(@(posedge clk)
	((sig_E < (sig_B == (sig_C ^ ~|sig_H))) == ((|sig_A === !sig_J) || sig_B))
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
nl2sva_machine,0_4,"If the value of sig_E is less than the result of the expression(sig_B equals the bitwise XOR of sig_C and the negation of ones' complement of sig_H), and this value equals the result of the expression((sig_A equals the bitwise negation of sig_J) or sig_B), then the assertion is true","assert property(@(posedge clk)
	((sig_E < (sig_B == (sig_C ^ ~|sig_H))) == ((|sig_A === !sig_J) || sig_B))
);","module dummy (
clk, reset_, 
sig_A,
sig_B,
sig_C,
sig_D,
sig_E
);

input clk;
input reset_;//clock and reset
input sig_A;  
input sig_B;
input sig_C;
input sig_D;  
input sig_E;

logic sig_F;
logic sig_G;
logic sig_H;
logic sig_I;
logic sig_J;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

assign sig_F = sig_A;
assign sig_G = sig_B;
assign sig_H = sig_C;
assign sig_I = sig_D;
assign sig_J = sig_E;


endmodule"
