{"task_id": "arbiter_0", "prompt": "that the arbiter grant signal is 0-1-hot"}
{"task_id": "arbiter_1", "prompt": "that the arbiter holds requests until valid"}
{"task_id": "arbiter_2", "prompt": "that whether starvation occurs, i.e. check that each request from client is eventually granted"}
{"task_id": "arbiter_3", "prompt": "that if there is a req, there will be a grant except when busy."}
{"task_id": "arbiter_4", "prompt": "that each grant must be to a requesting client only"}
{"task_id": "arbiter_5", "prompt": "that no grants are made when the arbiter downstream is busy"}
{"task_id": "arbiter_6", "prompt": "that the arbiter holds onto grants when there is hold"}
{"task_id": "arbiter_7", "prompt": "that the arbiter follows the Least Recently Used (LRU) policy with stickiness: always grant the least recently granted request that is currently requesting, but if  if sticky bit is high (hold) then keep granting the same client"}
{"task_id": "arbiter_8", "prompt": "that the grant of the arbiter stays sticky, i.e.  if sticky bit is high (hold) then keep granting the same client"}
{"task_id": "arbiter_12", "prompt": "that no grants are given while there is a grant bubble"}
{"task_id": "arbiter_13", "prompt": "that the grant of the arbiter stays sticky, i.e.  if sticky bit is high (hold) then keep granting the same client"}
{"task_id": "arbiter_9", "prompt": "that the arbiter is never on hold or busy or on continued grant at the same time"}
{"task_id": "arbiter_10", "prompt": "that each grant id is proper"}
{"task_id": "arbiter_11", "prompt": "that each grant id is proper, for the case where there no grants yet"}