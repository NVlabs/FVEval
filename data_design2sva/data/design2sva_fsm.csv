design_name,task_id,prompt,ref_solution,testbench
fsm,ni_4_nn_4_ne_4_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                if (((in_A != in_B) < 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_4_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
            end
            S2: begin
                next_state = S1;
            end
            S3: begin
                if (((in_A && in_B) || (in_A == in_D))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_4_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_A ^ in_D)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                next_state = S2;
            end
            S2: begin
            end
            S3: begin
                next_state = S0;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_4_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
            end
            S2: begin
                next_state = S1;
            end
            S3: begin
                if ((in_D || in_A)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (^(~^(in_A))) begin
                    next_state = S2;
                end
                else if (~|(in_B)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if (((in_B && in_C) < ~^(in_A))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                next_state = S3;
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (!(in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                next_state = S0;
            end
            S3: begin
                if ((^(in_A) != &(in_B))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
            end
            S2: begin
                next_state = S3;
            end
            S3: begin
                if ((in_D || in_B)) begin
                    next_state = S0;
                end
                else if ((in_A ^ (in_D || in_C))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_8_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_C != 'd0)) begin
                    next_state = S3;
                end
                else if (^((in_A && in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                next_state = S2;
            end
            S2: begin
                if ((in_C > 'd1)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_12_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_B ^ in_D)) begin
                    next_state = S1;
                end
                else if ((in_B != 'd1)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if (^(in_B)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if ((in_D == 'd0)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_12_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_C ^ in_D) ^ (in_A ^ in_D))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                next_state = S0;
            end
            S2: begin
                next_state = S1;
            end
            S3: begin
                if (((in_A ^ in_C) != 'd0)) begin
                    next_state = S0;
                end
                else if ((in_C ^ (in_D > 'd1))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_12_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (~(in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                if ((in_A && ~&(in_D))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if ((in_D == in_B)) begin
                    next_state = S1;
                end
                else if (((in_C || in_B) < in_A)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if ((in_D == 'd0)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S1;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_12_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_A == 'd1)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                if (((in_B != 'd1) && in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                next_state = S1;
            end
            S3: begin
                if ((in_D && (in_B == 'd0))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_16_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_A < 'd1) < in_C)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                if (((in_D != 'd1) && &(in_C))) begin
                    next_state = S0;
                end
                else if (|((in_A != in_B))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                if ((~&(in_B) == 'd1)) begin
                    next_state = S2;
                end
                else if ((in_D ^ (in_A == in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_16_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_A && in_D) == 'd1)) begin
                    next_state = S1;
                end
                else if (((in_D ^ in_B) != 'd0)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if ((~(in_A) || in_D)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                if (^((in_A == 'd1))) begin
                    next_state = S3;
                end
                else if ((in_D != (in_A || in_C))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if ((~(in_A) == 'd1)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_16_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((&(in_D) != in_C)) begin
                    next_state = S2;
                end
                else if ((in_D || in_C)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if ((in_D != 'd0)) begin
                    next_state = S3;
                end
                else if (~^(~|(in_B))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if ((in_D ^ in_B)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if ((~&(in_B) == 'd0)) begin
                    next_state = S0;
                end
                else if ((in_C == 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_4_ne_16_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_A == in_B) ^ (in_D != 'd1))) begin
                    next_state = S2;
                end
                else if ((in_A && (in_C && in_D))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                if (^((in_C && in_A))) begin
                    next_state = S0;
                end
                else if ((^(in_A) != 'd0)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if ((in_B ^ |(in_C))) begin
                    next_state = S0;
                end
                else if ((in_D && (in_C == in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_8_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S6;
            end
            S1: begin
                next_state = S5;
            end
            S2: begin
                if ((in_D && in_A)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
            S3: begin
                next_state = S4;
            end
            S4: begin
                if ((in_D ^ (in_A != in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S7;
                end
            end
            S5: begin
                next_state = S2;
            end
            S6: begin
                next_state = S0;
            end
            S7: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_8_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S5;
            end
            S1: begin
                next_state = S2;
            end
            S2: begin
            end
            S3: begin
                next_state = S1;
            end
            S4: begin
                next_state = S7;
            end
            S5: begin
                if ((~|(in_D) || in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S4;
                end
            end
            S6: begin
                if ((in_B && (in_A ^ in_C))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S5;
                end
            end
            S7: begin
                next_state = S6;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_8_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S6;
            end
            S1: begin
                next_state = S6;
            end
            S2: begin
                if (((in_D ^ in_A) || (in_D || in_C))) begin
                    next_state = S0;
                end
                else if (~^(in_B)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S7;
                end
            end
            S3: begin
                next_state = S4;
            end
            S4: begin
            end
            S5: begin
                next_state = S1;
            end
            S6: begin
                if ((in_D != (in_A && in_B))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S7: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_8_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S4;
            end
            S1: begin
                next_state = S6;
            end
            S2: begin
            end
            S3: begin
                next_state = S2;
            end
            S4: begin
                if (((in_B == in_C) && (in_A >= in_B))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S7;
                end
            end
            S5: begin
            end
            S6: begin
                if ((in_C != |(in_B))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S7: begin
                next_state = S5;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_16_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
                if ((in_D == in_B)) begin
                    next_state = S3;
                end
                else if (((in_C >= 'd0) && (in_B || in_D))) begin
                    next_state = S5;
                end
                else if ((in_A == 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
                next_state = S6;
            end
            S3: begin
            end
            S4: begin
                if (((in_D == 'd0) == 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S7;
                end
            end
            S5: begin
                next_state = S0;
            end
            S6: begin
                if ((in_B || (in_D < 'd1))) begin
                    next_state = S4;
                end
                else if ((in_B && (in_C != 'd0))) begin
                    next_state = S5;
                end
                else if ((in_B ^ ~^(in_C))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S2;
                end
            end
            S7: begin
                if (((in_D && in_C) != 'd0)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_16_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S7;
            end
            S1: begin
                if ((in_B != in_A)) begin
                    next_state = S6;
                end
                else if (((in_B == 'd0) == 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S5;
                end
            end
            S2: begin
                next_state = S5;
            end
            S3: begin
                if ((in_D != 'd1)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S4;
                end
            end
            S4: begin
                next_state = S2;
            end
            S5: begin
                if ((in_B == 'd0)) begin
                    next_state = S1;
                end
                else if (((in_D && in_B) == (in_A != 'd0))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S6: begin
            end
            S7: begin
                next_state = S3;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_16_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_C == (in_D != 'd0))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                next_state = S7;
            end
            S2: begin
                if ((in_D == 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S5;
                end
            end
            S3: begin
                if (((in_C == in_A) ^ in_C)) begin
                    next_state = S0;
                end
                else if ((in_C < (in_A != in_C))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S7;
                end
            end
            S4: begin
                next_state = S6;
            end
            S5: begin
            end
            S6: begin
                if ((in_A == 'd0)) begin
                    next_state = S1;
                end
                else if ((in_A == 'd0)) begin
                    next_state = S2;
                end
                else if (((in_A == 'd0) > in_D)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S3;
                end
            end
            S7: begin
                if ((in_B != 'd1)) begin
                    next_state = S5;
                end
                else if ((in_A != 'd1)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_16_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (~((in_C || in_B))) begin
                    next_state = S3;
                end
                else if (((in_C == in_A) == 'd1)) begin
                    next_state = S4;
                end
                else if ((in_B <= 'd1)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S5;
                end
            end
            S1: begin
                next_state = S6;
            end
            S2: begin
                if ((in_A <= 'd1)) begin
                    next_state = S7;
                end
                else if ((|(in_C) || in_A)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                next_state = S2;
            end
            S4: begin
                if ((in_D != (in_A || in_C))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S6;
                end
            end
            S5: begin
                next_state = S0;
            end
            S6: begin
                next_state = S0;
            end
            S7: begin
                if (((in_A || in_C) != in_A)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_24_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((^(in_C) < 'd0)) begin
                    next_state = S2;
                end
                else if ((in_D || (in_B != 'd0))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S1: begin
                if (~^(in_C)) begin
                    next_state = S5;
                end
                else if (((in_C || in_B) != 'd0)) begin
                    next_state = S6;
                end
                else if (|((in_B == 'd0))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S4;
                end
            end
            S2: begin
                if (((in_D == 'd1) ^ (in_C <= in_B))) begin
                    next_state = S1;
                end
                else if ((in_D == 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                next_state = S0;
            end
            S4: begin
            end
            S5: begin
                if ((in_C || in_D)) begin
                    next_state = S0;
                end
                else if (~&(in_D)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S6;
                end
            end
            S6: begin
                if ((in_A == (in_B != in_D))) begin
                    next_state = S3;
                end
                else if (((in_A < 'd1) || (in_C < 'd1))) begin
                    next_state = S0;
                end
                else if ((!(in_C) && ~^(in_A))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S2;
                end
            end
            S7: begin
                if (((in_C || in_D) && (in_C && in_B))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S4;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_24_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                if (&(~|(in_D))) begin
                    next_state = S0;
                end
                else if (((in_B < in_A) || in_B)) begin
                    next_state = S4;
                end
                else if ((&(in_C) ^ (in_A != 'd0))) begin
                    next_state = S2;
                end
                else if ((in_A ^ ~^(in_D))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                if (~|((in_D == 'd1))) begin
                    next_state = S3;
                end
                else if (((in_C == 'd0) == 'd1)) begin
                    next_state = S4;
                end
                else if (((in_D != 'd1) ^ in_C)) begin
                    next_state = S1;
                end
                else if (~^((in_D == in_B))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if ((in_D != in_B)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S4: begin
                next_state = S6;
            end
            S5: begin
            end
            S6: begin
                if ((~|(in_A) && in_B)) begin
                    next_state = S7;
                end
                else if ((in_C == 'd1)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S4;
                end
            end
            S7: begin
                if ((in_C != 'd1)) begin
                    next_state = S1;
                end
                else if ((in_C != 'd1)) begin
                    next_state = S5;
                end
                else if (((in_D && in_B) && in_D)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S3;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_24_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                if (~(in_A)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S7;
                end
            end
            S2: begin
                if ((in_A != 'd1)) begin
                    next_state = S3;
                end
                else if (!((in_D == 'd1))) begin
                    next_state = S1;
                end
                else if (~^((in_D && in_B))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S4;
                end
            end
            S3: begin
                if ((in_C != 'd1)) begin
                    next_state = S5;
                end
                else if (((in_C > in_A) || (in_B || in_D))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S7;
                end
            end
            S4: begin
                if (((in_A || in_B) < 'd1)) begin
                    next_state = S1;
                end
                else if (~((in_C || in_B))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S5: begin
                if (((in_D && in_C) != (in_B == 'd0))) begin
                    next_state = S0;
                end
                else if ((in_B != ~&(in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S6: begin
                if (^(in_A)) begin
                    next_state = S1;
                end
                else if ((!(in_C) != 'd0)) begin
                    next_state = S7;
                end
                else if (((in_C == 'd1) && (in_B ^ in_A))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
                if ((in_C <= 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_24_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_C && (in_D || in_A))) begin
                    next_state = S3;
                end
                else if ((in_D <= 'd0)) begin
                    next_state = S6;
                end
                else if (((in_C == in_D) ^ in_A)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                if ((!(in_A) != (in_D >= 'd0))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S4;
                end
            end
            S2: begin
                if ((in_B || in_D)) begin
                    next_state = S7;
                end
                else if ((!(in_D) || (in_A && in_C))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S6;
                end
            end
            S3: begin
                next_state = S6;
            end
            S4: begin
                if ((in_C && in_B)) begin
                    next_state = S0;
                end
                else if (((in_A != 'd1) != (in_B && in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S6;
                end
            end
            S5: begin
                if (~&(in_C)) begin
                    next_state = S2;
                end
                else if ((in_C != 'd0)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S1;
                end
            end
            S6: begin
                if (!((in_D >= 'd1))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S1;
                end
            end
            S7: begin
                if ((in_A || in_C)) begin
                    next_state = S1;
                end
                else if ((in_C && in_B)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_32_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_D == in_C) > 'd0)) begin
                    next_state = S2;
                end
                else if ((^(in_B) || in_C)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S4;
                end
            end
            S1: begin
            end
            S2: begin
                if ((in_B && in_C)) begin
                    next_state = S1;
                end
                else if ((in_C != 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                if ((in_C == in_D)) begin
                    next_state = S0;
                end
                else if (((in_D == in_C) == (in_A && in_C))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S2;
                end
            end
            S4: begin
                if ((in_B == 'd0)) begin
                    next_state = S3;
                end
                else if (((in_A ^ in_C) == 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
            S5: begin
                if (((in_C ^ in_A) && in_D)) begin
                    next_state = S0;
                end
                else if ((in_B && ~^(in_D))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S4;
                end
            end
            S6: begin
                if ((in_D ^ in_C)) begin
                    next_state = S3;
                end
                else if (~^(in_B)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S7: begin
                if ((in_C ^ (in_D == 'd1))) begin
                    next_state = S6;
                end
                else if (^(in_C)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S1;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_32_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_D ^ |(in_C))) begin
                    next_state = S5;
                end
                else if ((in_C ^ (in_D != 'd1))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                if ((in_A || (in_B != 'd1))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                next_state = S5;
            end
            S3: begin
                if ((in_B >= 'd0)) begin
                    next_state = S1;
                end
                else if (!(in_C)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S5;
                end
            end
            S4: begin
                if (((in_A == 'd1) || ~&(in_B))) begin
                    next_state = S6;
                end
                else if (((in_D ^ in_A) == (in_D && in_C))) begin
                    next_state = S0;
                end
                else if (((in_A ^ in_B) ^ in_A)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S5;
                end
            end
            S5: begin
                next_state = S7;
            end
            S6: begin
                if (~((in_A || in_C))) begin
                    next_state = S0;
                end
                else if (((in_C <= in_B) || (in_C && in_A))) begin
                    next_state = S2;
                end
                else if ((in_A && (in_B || in_A))) begin
                    next_state = S4;
                end
                else if (((in_B ^ in_C) == 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S5;
                end
            end
            S7: begin
                if ((in_A != 'd0)) begin
                    next_state = S1;
                end
                else if (((in_A || in_C) ^ in_D)) begin
                    next_state = S3;
                end
                else if ((in_D != 'd0)) begin
                    next_state = S4;
                end
                else if ((in_D || in_C)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_32_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (!(in_D)) begin
                    next_state = S5;
                end
                else if ((in_C ^ in_A)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S7;
                end
            end
            S1: begin
                if ((!(in_D) ^ in_C)) begin
                    next_state = S6;
                end
                else if ((in_C != 'd0)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if ((in_D && in_A)) begin
                    next_state = S7;
                end
                else if (((in_A < in_B) == in_C)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if ((in_A < 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S5;
                end
            end
            S4: begin
                if ((in_B != 'd0)) begin
                    next_state = S1;
                end
                else if (((in_D != 'd0) <= 'd1)) begin
                    next_state = S5;
                end
                else if ((in_C != 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S5: begin
                next_state = S3;
            end
            S6: begin
                if (((in_D || in_C) ^ in_A)) begin
                    next_state = S0;
                end
                else if ((in_C ^ in_A)) begin
                    next_state = S2;
                end
                else if ((in_C == 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S3;
                end
            end
            S7: begin
                if (~^(in_A)) begin
                    next_state = S3;
                end
                else if (((in_B == 'd0) == &(in_D))) begin
                    next_state = S0;
                end
                else if (((in_A || in_B) || in_A)) begin
                    next_state = S2;
                end
                else if ((in_C && in_D)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_8_ne_32_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_D && in_A)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S4;
                end
            end
            S1: begin
                if ((in_D || in_B)) begin
                    next_state = S7;
                end
                else if ((in_A > 'd1)) begin
                    next_state = S5;
                end
                else if ((in_D != 'd0)) begin
                    next_state = S3;
                end
                else if (((in_B && in_A) && (in_D == 'd1))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if (((in_B == 'd1) == in_D)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if ((in_C == 'd1)) begin
                    next_state = S6;
                end
                else if (((in_B || in_C) || in_A)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S2;
                end
            end
            S4: begin
                if (((in_D != in_B) != 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S5: begin
                if (((in_C != in_D) ^ in_B)) begin
                    next_state = S2;
                end
                else if (~^(in_D)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S1;
                end
            end
            S6: begin
                if (^((in_A > 'd1))) begin
                    next_state = S4;
                end
                else if (((in_D && in_C) != (in_A != in_C))) begin
                    next_state = S1;
                end
                else if ((in_B ^ (in_A && in_D))) begin
                    next_state = S7;
                end
                else if (&((in_A || in_B))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S5;
                end
            end
            S7: begin
                if ((in_D == 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_16_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S9;
            end
            S1: begin
                if ((in_B && in_C)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
            end
            S3: begin
                if ((in_A || in_B)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S8;
                end
            end
            S4: begin
                if (~((in_A ^ in_B))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S5;
                end
            end
            S5: begin
            end
            S6: begin
                if (((in_C && in_D) == (in_A <= 'd1))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S13;
                end
            end
            S7: begin
                if (((in_A || in_C) <= in_A)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S15;
                end
            end
            S8: begin
            end
            S9: begin
                next_state = S10;
            end
            S10: begin
                next_state = S14;
            end
            S11: begin
                next_state = S7;
            end
            S12: begin
            end
            S13: begin
            end
            S14: begin
            end
            S15: begin
                if (((in_C == 'd0) == 'd1)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S4;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_16_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_D || in_A)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S7;
                end
            end
            S1: begin
                if ((in_D && in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S9;
                end
            end
            S2: begin
            end
            S3: begin
                next_state = S14;
            end
            S4: begin
            end
            S5: begin
            end
            S6: begin
            end
            S7: begin
            end
            S8: begin
            end
            S9: begin
            end
            S10: begin
                next_state = S1;
            end
            S11: begin
                if ((in_A || in_D)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S12;
                end
            end
            S12: begin
                if (~^((in_C ^ in_A))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S13;
                end
            end
            S13: begin
                next_state = S2;
            end
            S14: begin
                if ((in_D != 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S15;
                end
            end
            S15: begin
                if ((in_C != in_D)) begin
                    next_state = S0;
                end
                else if ((in_D && in_C)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S8;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_16_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S11;
            end
            S1: begin
                if ((in_C && (in_A != 'd1))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S12;
                end
            end
            S2: begin
                if (~^(in_B)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S14;
                end
            end
            S3: begin
            end
            S4: begin
            end
            S5: begin
                next_state = S9;
            end
            S6: begin
                next_state = S5;
            end
            S7: begin
                if ((in_C != 'd1)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S10;
                end
            end
            S8: begin
            end
            S9: begin
            end
            S10: begin
                if (((in_B && in_D) != 'd0)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S15;
                end
            end
            S11: begin
                next_state = S1;
            end
            S12: begin
            end
            S13: begin
                if (|((in_D || in_B))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S6;
                end
            end
            S14: begin
            end
            S15: begin
                if (((in_C ^ in_D) == 'd0)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S8;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_16_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                next_state = S5;
            end
            S2: begin
            end
            S3: begin
                if (~(!(in_D))) begin
                    next_state = S4;
                end
                else if ((in_C && (in_B != 'd1))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S11;
                end
            end
            S4: begin
                if ((in_B || in_C)) begin
                    next_state = S2;
                end
                else if ((in_D || in_A)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S15;
                end
            end
            S5: begin
                next_state = S3;
            end
            S6: begin
                next_state = S14;
            end
            S7: begin
            end
            S8: begin
                next_state = S12;
            end
            S9: begin
                next_state = S7;
            end
            S10: begin
            end
            S11: begin
                if ((in_C ^ (in_D ^ in_B))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S6;
                end
            end
            S12: begin
                next_state = S10;
            end
            S13: begin
            end
            S14: begin
            end
            S15: begin
                next_state = S9;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S8;
            end
            S1: begin
                if (~^(in_A)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S14;
                end
            end
            S2: begin
                if (~^(in_C)) begin
                    next_state = S0;
                end
                else if ((in_A != in_B)) begin
                    next_state = S11;
                end
                else if (((in_C ^ in_B) != in_D)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S14;
                end
            end
            S3: begin
                if (~(in_C)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S11;
                end
            end
            S4: begin
            end
            S5: begin
                if (~&(in_A)) begin
                    next_state = S1;
                end
                else if (!(in_B)) begin
                    next_state = S4;
                end
                else if (~((in_C || in_D))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S12;
                end
            end
            S6: begin
            end
            S7: begin
                if (~((in_B > in_C))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S2;
                end
            end
            S8: begin
                if (((in_D == 'd0) != 'd0)) begin
                    next_state = S2;
                end
                else if ((^(in_D) != 'd0)) begin
                    next_state = S3;
                end
                else if (((in_C > 'd0) && in_D)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S15;
                end
            end
            S9: begin
                next_state = S14;
            end
            S10: begin
                if (((in_A != in_D) || (in_B ^ in_D))) begin
                    next_state = S9;
                end
                else if (((in_A != in_B) && in_D)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S7;
                end
            end
            S11: begin
            end
            S12: begin
                if (|(in_D)) begin
                    next_state = S7;
                end
                else if ((in_B ^ |(in_A))) begin
                    next_state = S13;
                end
                else if ((in_B == 'd0)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S6;
                end
            end
            S13: begin
                next_state = S6;
            end
            S14: begin
            end
            S15: begin
                next_state = S6;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_A && in_D)) begin
                    next_state = S11;
                end
                else if (^(in_A)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S8;
                end
            end
            S1: begin
                next_state = S12;
            end
            S2: begin
                if (!(in_B)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S8;
                end
            end
            S3: begin
                if (((in_B && in_A) || (in_B != 'd1))) begin
                    next_state = S1;
                end
                else if (((in_C && in_B) || in_C)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S6;
                end
            end
            S4: begin
            end
            S5: begin
                if (((in_A == 'd1) != 'd0)) begin
                    next_state = S7;
                end
                else if ((in_B ^ in_C)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S1;
                end
            end
            S6: begin
                if ((in_A ^ in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
                if ((in_D == (in_B && in_A))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S5;
                end
            end
            S8: begin
                if (((in_A ^ in_C) && in_D)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S9: begin
                if ((in_B == 'd1)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S10;
                end
            end
            S10: begin
                if (~|(in_D)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S15;
                end
            end
            S11: begin
                next_state = S10;
            end
            S12: begin
                if (((in_B >= 'd1) || in_A)) begin
                    next_state = S3;
                end
                else if (((in_C != 'd1) == in_A)) begin
                    next_state = S5;
                end
                else if (((in_A || in_B) ^ (in_C || in_B))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S14;
                end
            end
            S13: begin
                next_state = S12;
            end
            S14: begin
                next_state = S2;
            end
            S15: begin
                if ((in_A == 'd1)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S13;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_D != in_C) || in_B)) begin
                    next_state = S13;
                end
                else if (((in_C ^ in_D) != (in_A == 'd1))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                next_state = S0;
            end
            S2: begin
                if ((in_A ^ in_D)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S8;
                end
            end
            S3: begin
                if ((in_C || in_D)) begin
                    next_state = S11;
                end
                else if (&((in_C != in_A))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S6;
                end
            end
            S4: begin
            end
            S5: begin
                if (((in_A != 'd0) && in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
            S6: begin
                if ((in_C != 'd1)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S14;
                end
            end
            S7: begin
            end
            S8: begin
                if ((in_A != 'd0)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S11;
                end
            end
            S9: begin
                next_state = S12;
            end
            S10: begin
                if ((in_A || (in_B || in_A))) begin
                    next_state = S1;
                end
                else if ((in_A != 'd0)) begin
                    next_state = S8;
                end
                else if (((in_A == 'd1) && (in_B ^ in_A))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S15;
                end
            end
            S11: begin
                if ((~^(in_D) != in_B)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S10;
                end
            end
            S12: begin
                if (((in_D != 'd1) ^ in_C)) begin
                    next_state = S2;
                end
                else if ((in_C == 'd1)) begin
                    next_state = S10;
                end
                else if ((in_D ^ in_A)) begin
                    next_state = S7;
                end
                else if ((~&(in_D) == in_C)) begin
                    next_state = S15;
                end
                else if (~&(in_D)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S5;
                end
            end
            S13: begin
                if (((in_D == 'd0) && (in_C && in_D))) begin
                    next_state = S0;
                end
                else if (((in_A ^ in_D) != 'd0)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S15;
                end
            end
            S14: begin
            end
            S15: begin
                next_state = S9;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_32_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_D || (in_C <= in_D))) begin
                    next_state = S6;
                end
                else if ((in_B && in_A)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S15;
                end
            end
            S1: begin
                if ((in_D != 'd1)) begin
                    next_state = S10;
                end
                else if ((in_A != 'd1)) begin
                    next_state = S3;
                end
                else if ((in_A || (in_D ^ in_A))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S4;
                end
            end
            S2: begin
                if (&((in_A != 'd0))) begin
                    next_state = S14;
                end
                else if ((~&(in_A) == (in_B || in_C))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S10;
                end
            end
            S3: begin
                next_state = S14;
            end
            S4: begin
                if ((in_C == (in_A != 'd0))) begin
                    next_state = S3;
                end
                else if (~|(in_D)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S13;
                end
            end
            S5: begin
                next_state = S2;
            end
            S6: begin
                if ((in_A ^ (in_B || in_A))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S9;
                end
            end
            S7: begin
                if ((in_B && in_C)) begin
                    next_state = S4;
                end
                else if (!((in_D && in_B))) begin
                    next_state = S5;
                end
                else if (((in_A || in_D) ^ in_B)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S8;
                end
            end
            S8: begin
                next_state = S1;
            end
            S9: begin
            end
            S10: begin
                if (((in_D == 'd1) <= (in_B || in_D))) begin
                    next_state = S15;
                end
                else if (((in_C != 'd0) != 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S11;
                end
            end
            S11: begin
                next_state = S0;
            end
            S12: begin
                next_state = S13;
            end
            S13: begin
                next_state = S8;
            end
            S14: begin
                if ((in_C == in_B)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S10;
                end
            end
            S15: begin
                next_state = S8;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_48_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_B || (in_C && in_D))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                if ((in_D || (in_A ^ in_D))) begin
                    next_state = S6;
                end
                else if ((in_B != 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S5;
                end
            end
            S2: begin
                if ((in_D ^ in_B)) begin
                    next_state = S9;
                end
                else if (((in_B ^ in_A) ^ in_B)) begin
                    next_state = S13;
                end
                else if ((in_C ^ in_A)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S5;
                end
            end
            S3: begin
                if ((in_D != 'd1)) begin
                    next_state = S0;
                end
                else if (((in_C || in_D) > (in_A || in_C))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S10;
                end
            end
            S4: begin
                if ((in_A != (in_B > 'd1))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S9;
                end
            end
            S5: begin
            end
            S6: begin
                if ((in_A < in_C)) begin
                    next_state = S3;
                end
                else if ((~^(in_D) > 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S7;
                end
            end
            S7: begin
                if (((in_D == 'd0) == 'd1)) begin
                    next_state = S4;
                end
                else if ((in_B && in_C)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S11;
                end
            end
            S8: begin
                if ((~^(in_C) || in_A)) begin
                    next_state = S9;
                end
                else if (~&((in_D && in_C))) begin
                    next_state = S3;
                end
                else if ((in_C ^ (in_B && in_C))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S11;
                end
            end
            S9: begin
                if ((~(in_A) == in_D)) begin
                    next_state = S1;
                end
                else if (((in_B == 'd1) != (in_C ^ in_B))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S2;
                end
            end
            S10: begin
                if (((in_C && in_D) == 'd1)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S6;
                end
            end
            S11: begin
                if (((in_C != in_A) || ~&(in_D))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S4;
                end
            end
            S12: begin
                if (((in_D ^ in_B) ^ (in_D ^ in_C))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S15;
                end
            end
            S13: begin
                if ((in_D || in_A)) begin
                    next_state = S8;
                end
                else if ((in_A ^ (in_D != 'd0))) begin
                    next_state = S10;
                end
                else if ((in_C || (in_A ^ in_B))) begin
                    next_state = S14;
                end
                else if ((&(in_C) ^ in_B)) begin
                    next_state = S2;
                end
                else if (((in_A || in_B) && (in_C != 'd0))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S15;
                end
            end
            S14: begin
                if (^(in_D)) begin
                    next_state = S5;
                end
                else if ((in_A || ^(in_D))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S11;
                end
            end
            S15: begin
                if ((in_D && in_B)) begin
                    next_state = S2;
                end
                else if (&((in_B >= 'd0))) begin
                    next_state = S10;
                end
                else if (~((in_C != in_B))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_48_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_A > in_C)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S14;
                end
            end
            S1: begin
                next_state = S12;
            end
            S2: begin
                if (!(in_A)) begin
                    next_state = S7;
                end
                else if ((in_D == (in_B && in_C))) begin
                    next_state = S9;
                end
                else if ((in_B || (in_A == 'd1))) begin
                    next_state = S15;
                end
                else begin
                    next_state = S12;
                end
            end
            S3: begin
                if (((in_D >= 'd1) ^ (in_A == 'd0))) begin
                    next_state = S6;
                end
                else if ((in_D < in_C)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S5;
                end
            end
            S4: begin
                if ((in_A != 'd1)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S10;
                end
            end
            S5: begin
                if (((in_C == 'd0) == 'd0)) begin
                    next_state = S14;
                end
                else if ((in_A || (in_B > 'd1))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S9;
                end
            end
            S6: begin
                if (((in_D ^ in_A) == 'd0)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S11;
                end
            end
            S7: begin
                if (~^(in_A)) begin
                    next_state = S11;
                end
                else if ((in_D != 'd0)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S6;
                end
            end
            S8: begin
                if (((in_B ^ in_C) && in_D)) begin
                    next_state = S6;
                end
                else if ((in_B == 'd0)) begin
                    next_state = S5;
                end
                else if ((in_A || (in_B || in_A))) begin
                    next_state = S10;
                end
                else if (~&((in_C || in_B))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S14;
                end
            end
            S9: begin
                if ((in_D != (in_C == in_D))) begin
                    next_state = S8;
                end
                else if ((|(in_D) != 'd0)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S12;
                end
            end
            S10: begin
                if ((in_B && (in_C != 'd0))) begin
                    next_state = S3;
                end
                else if ((in_A != 'd1)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S9;
                end
            end
            S11: begin
                if ((in_C > |(in_A))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S12: begin
                if ((&(in_A) ^ (in_D == 'd1))) begin
                    next_state = S15;
                end
                else begin
                    next_state = S6;
                end
            end
            S13: begin
                if ((in_A == 'd0)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S5;
                end
            end
            S14: begin
                if ((in_A >= (in_D == 'd1))) begin
                    next_state = S5;
                end
                else if (((in_C == 'd0) == 'd0)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S6;
                end
            end
            S15: begin
                if (^(in_A)) begin
                    next_state = S0;
                end
                else if (((in_D == 'd0) && (in_C || in_A))) begin
                    next_state = S10;
                end
                else begin
                    next_state = S12;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_48_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_C && in_B)) begin
                    next_state = S1;
                end
                else if (~&(~^(in_A))) begin
                    next_state = S2;
                end
                else if ((~^(in_C) != 'd1)) begin
                    next_state = S12;
                end
                else if ((~|(in_D) != in_C)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S11;
                end
            end
            S1: begin
                if ((~(in_D) == 'd1)) begin
                    next_state = S6;
                end
                else if (~&(in_A)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S14;
                end
            end
            S2: begin
                if ((in_A || in_D)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S5;
                end
            end
            S3: begin
                if (((in_A ^ in_B) || in_D)) begin
                    next_state = S5;
                end
                else if (~^(in_D)) begin
                    next_state = S8;
                end
                else if ((in_D == in_C)) begin
                    next_state = S15;
                end
                else if ((~|(in_C) && (in_D == 'd0))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S10;
                end
            end
            S4: begin
                if (((in_A && in_B) || (in_A == in_C))) begin
                    next_state = S2;
                end
                else if (((in_B == in_A) != in_B)) begin
                    next_state = S9;
                end
                else if (((in_C && in_D) != (in_C != 'd0))) begin
                    next_state = S15;
                end
                else if ((in_B >= 'd1)) begin
                    next_state = S6;
                end
                else if (((in_B == 'd0) && in_C)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S5;
                end
            end
            S5: begin
                next_state = S2;
            end
            S6: begin
                if ((in_A && (in_B && in_D))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S3;
                end
            end
            S7: begin
                if ((in_C == in_B)) begin
                    next_state = S0;
                end
                else if (((in_A || in_B) && in_D)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S13;
                end
            end
            S8: begin
                if (^(in_D)) begin
                    next_state = S10;
                end
                else if (((in_C ^ in_D) == in_B)) begin
                    next_state = S11;
                end
                else if ((in_C != (in_D != 'd1))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S6;
                end
            end
            S9: begin
                if (((in_D && in_B) || (in_A == in_D))) begin
                    next_state = S7;
                end
                else if ((in_A ^ in_D)) begin
                    next_state = S12;
                end
                else if ((in_D == 'd1)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S2;
                end
            end
            S10: begin
                next_state = S3;
            end
            S11: begin
            end
            S12: begin
                if ((in_C || &(in_D))) begin
                    next_state = S4;
                end
                else if ((!(in_A) >= in_C)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S13;
                end
            end
            S13: begin
                if (((in_D != in_A) != 'd0)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S0;
                end
            end
            S14: begin
                next_state = S10;
            end
            S15: begin
                next_state = S5;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_48_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_A == 'd1)) begin
                    next_state = S13;
                end
                else if ((in_B == 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S12;
                end
            end
            S1: begin
                if ((~|(in_C) || in_D)) begin
                    next_state = S7;
                end
                else if (((in_D == 'd1) != 'd0)) begin
                    next_state = S6;
                end
                else if ((in_A <= 'd1)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if ((in_D == 'd1)) begin
                    next_state = S1;
                end
                else if ((in_B != 'd1)) begin
                    next_state = S4;
                end
                else if ((^(in_A) || (in_B && in_A))) begin
                    next_state = S14;
                end
                else begin
                    next_state = S10;
                end
            end
            S3: begin
                if ((in_B != 'd0)) begin
                    next_state = S2;
                end
                else if ((in_C ^ in_B)) begin
                    next_state = S10;
                end
                else if (((in_C >= in_A) != 'd1)) begin
                    next_state = S13;
                end
                else if (((in_A || in_C) != 'd0)) begin
                    next_state = S14;
                end
                else if ((in_A && (in_B == in_D))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S7;
                end
            end
            S4: begin
                next_state = S5;
            end
            S5: begin
                next_state = S15;
            end
            S6: begin
                if ((in_C != (in_B && in_A))) begin
                    next_state = S3;
                end
                else if (~|((in_D ^ in_C))) begin
                    next_state = S5;
                end
                else if (((in_B ^ in_D) != 'd0)) begin
                    next_state = S11;
                end
                else if (((in_A != in_B) && in_D)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S14;
                end
            end
            S7: begin
                if (((in_D > 'd1) ^ in_B)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S2;
                end
            end
            S8: begin
                if ((!(in_B) == (in_A ^ in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S12;
                end
            end
            S9: begin
            end
            S10: begin
                if (~|(in_B)) begin
                    next_state = S0;
                end
                else if (((in_D && in_C) ^ ~(in_B))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S12;
                end
            end
            S11: begin
                if (!(in_B)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S10;
                end
            end
            S12: begin
                if (((in_D == 'd0) == in_B)) begin
                    next_state = S14;
                end
                else if (^(in_B)) begin
                    next_state = S1;
                end
                else if ((in_A || in_D)) begin
                    next_state = S15;
                end
                else if ((&(in_B) != ~(in_C))) begin
                    next_state = S3;
                end
                else if (((in_D != in_A) || (in_B ^ in_C))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S4;
                end
            end
            S13: begin
                next_state = S6;
            end
            S14: begin
                if (((in_B >= in_D) >= 'd0)) begin
                    next_state = S12;
                end
                else if (((in_D && in_C) != in_B)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S15: begin
                next_state = S7;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_64_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (~^((in_D && in_A))) begin
                    next_state = S1;
                end
                else if ((in_A == 'd0)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                if ((in_C ^ (in_A && in_B))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S14;
                end
            end
            S2: begin
                if ((in_C != 'd0)) begin
                    next_state = S10;
                end
                else if ((in_D != 'd0)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if ((in_B != 'd0)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S12;
                end
            end
            S4: begin
                if (!((in_B < 'd0))) begin
                    next_state = S2;
                end
                else if ((in_D == 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S1;
                end
            end
            S5: begin
                if (((in_C != in_B) != 'd0)) begin
                    next_state = S7;
                end
                else if (((in_D ^ in_C) != (in_A || in_D))) begin
                    next_state = S10;
                end
                else if (((in_A <= 'd0) == 'd1)) begin
                    next_state = S14;
                end
                else if ((in_D != 'd1)) begin
                    next_state = S3;
                end
                else if ((in_D && in_B)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S8;
                end
            end
            S6: begin
                if ((in_D == 'd1)) begin
                    next_state = S1;
                end
                else if (((in_B || in_C) == in_D)) begin
                    next_state = S8;
                end
                else if ((in_A == 'd0)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S7;
                end
            end
            S7: begin
                if ((in_C ^ (in_A || in_D))) begin
                    next_state = S4;
                end
                else if (((in_B || in_D) ^ ^(in_B))) begin
                    next_state = S12;
                end
                else if (((in_D == 'd0) <= 'd0)) begin
                    next_state = S1;
                end
                else if ((in_A != 'd0)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S3;
                end
            end
            S8: begin
                if (((in_D != in_A) == 'd0)) begin
                    next_state = S6;
                end
                else if ((in_A > 'd0)) begin
                    next_state = S15;
                end
                else if ((|(in_A) && (in_D == 'd0))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S2;
                end
            end
            S9: begin
                if (^(in_D)) begin
                    next_state = S3;
                end
                else if (((in_B ^ in_D) || (in_C == in_D))) begin
                    next_state = S8;
                end
                else if (~&((in_B != 'd0))) begin
                    next_state = S7;
                end
                else if ((in_D != 'd1)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S4;
                end
            end
            S10: begin
                if ((in_B || |(in_A))) begin
                    next_state = S0;
                end
                else if (((in_C && in_B) != 'd1)) begin
                    next_state = S11;
                end
                else if (|(~(in_B))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S14;
                end
            end
            S11: begin
                if ((in_A ^ in_B)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S1;
                end
            end
            S12: begin
                if (((in_D == 'd0) ^ ~(in_C))) begin
                    next_state = S15;
                end
                else if (((in_D >= 'd1) ^ ~|(in_B))) begin
                    next_state = S14;
                end
                else if ((in_B != 'd0)) begin
                    next_state = S11;
                end
                else if (((in_A >= 'd0) == 'd1)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S1;
                end
            end
            S13: begin
                if (!((in_C || in_D))) begin
                    next_state = S5;
                end
                else if (((in_C ^ in_A) && (in_B ^ in_C))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S6;
                end
            end
            S14: begin
                if ((~|(in_C) ^ (in_A && in_C))) begin
                    next_state = S13;
                end
                else if ((in_C && (in_B ^ in_A))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S5;
                end
            end
            S15: begin
                if (^((in_D ^ in_C))) begin
                    next_state = S3;
                end
                else if ((in_D && (in_A ^ in_C))) begin
                    next_state = S6;
                end
                else if (((in_B == 'd0) && in_C)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S13;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_64_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_C || in_A)) begin
                    next_state = S1;
                end
                else if (~^((in_A <= 'd1))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S4;
                end
            end
            S1: begin
                if ((in_A == 'd1)) begin
                    next_state = S0;
                end
                else if (((in_B == 'd1) || in_C)) begin
                    next_state = S6;
                end
                else if (((in_D ^ in_A) == 'd0)) begin
                    next_state = S13;
                end
                else if (~&((in_B != 'd0))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                if ((in_B || ~|(in_A))) begin
                    next_state = S0;
                end
                else if (((in_A != 'd1) && (in_D && in_C))) begin
                    next_state = S4;
                end
                else if ((in_D && in_A)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S14;
                end
            end
            S3: begin
                if (~^((in_B != 'd1))) begin
                    next_state = S8;
                end
                else if (~^((in_C >= 'd0))) begin
                    next_state = S12;
                end
                else if (((in_A != 'd0) || in_C)) begin
                    next_state = S14;
                end
                else if ((~(in_A) ^ (in_C ^ in_D))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S15;
                end
            end
            S4: begin
                if ((in_D == 'd0)) begin
                    next_state = S10;
                end
                else if (~&((in_A > 'd0))) begin
                    next_state = S11;
                end
                else if ((in_C == 'd1)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S12;
                end
            end
            S5: begin
                if (~&(in_D)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S12;
                end
            end
            S6: begin
                if (!((in_C == 'd1))) begin
                    next_state = S2;
                end
                else if (~&(in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S5;
                end
            end
            S7: begin
                if ((in_A == 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S13;
                end
            end
            S8: begin
                if ((in_B > in_C)) begin
                    next_state = S13;
                end
                else if ((in_A && in_C)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S9: begin
                if (((in_B > 'd1) && in_C)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S2;
                end
            end
            S10: begin
                if ((in_B ^ (in_D == 'd0))) begin
                    next_state = S4;
                end
                else if (((in_A && in_D) == 'd0)) begin
                    next_state = S6;
                end
                else if ((in_D == 'd1)) begin
                    next_state = S11;
                end
                else if (!(in_D)) begin
                    next_state = S5;
                end
                else if ((~&(in_B) && ~&(in_A))) begin
                    next_state = S12;
                end
                else if ((in_A ^ (in_D == in_C))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S15;
                end
            end
            S11: begin
                if ((in_B || in_C)) begin
                    next_state = S3;
                end
                else if ((~&(in_C) != 'd1)) begin
                    next_state = S5;
                end
                else if ((in_C ^ in_B)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S12;
                end
            end
            S12: begin
                if ((in_C == 'd1)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S2;
                end
            end
            S13: begin
                if ((in_A != in_C)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S11;
                end
            end
            S14: begin
                if (((in_B != 'd0) < in_C)) begin
                    next_state = S4;
                end
                else if ((in_B ^ in_D)) begin
                    next_state = S12;
                end
                else if ((in_B == 'd1)) begin
                    next_state = S2;
                end
                else if ((in_C && in_A)) begin
                    next_state = S1;
                end
                else if (((in_D != in_A) || in_B)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S13;
                end
            end
            S15: begin
                if (&((in_C && in_B))) begin
                    next_state = S7;
                end
                else if (^(in_C)) begin
                    next_state = S1;
                end
                else if (((in_D ^ in_A) || in_C)) begin
                    next_state = S12;
                end
                else if ((in_C && (in_D && in_B))) begin
                    next_state = S10;
                end
                else begin
                    next_state = S3;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_64_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((~|(in_A) ^ (in_D != in_A))) begin
                    next_state = S13;
                end
                else if (~&(~(in_C))) begin
                    next_state = S14;
                end
                else if (((in_B ^ in_A) == 'd1)) begin
                    next_state = S5;
                end
                else if (((in_C && in_A) && in_B)) begin
                    next_state = S10;
                end
                else if ((~(in_A) && in_D)) begin
                    next_state = S8;
                end
                else if (((in_C != in_D) <= (in_B == in_A))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S4;
                end
            end
            S1: begin
                if (((in_B > in_D) == ~(in_C))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S2: begin
                if ((in_D || (in_C == in_A))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if (((in_A || in_D) != (in_A ^ in_B))) begin
                    next_state = S0;
                end
                else if (((in_A || in_C) == 'd0)) begin
                    next_state = S2;
                end
                else if (!(in_B)) begin
                    next_state = S5;
                end
                else if ((in_C && (in_D || in_B))) begin
                    next_state = S12;
                end
                else if (((in_A == 'd0) || in_C)) begin
                    next_state = S10;
                end
                else if (((in_A != 'd0) == (in_D < in_A))) begin
                    next_state = S6;
                end
                else if ((~|(in_C) ^ (in_D == 'd1))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S15;
                end
            end
            S4: begin
                if (((in_A != 'd1) < 'd1)) begin
                    next_state = S10;
                end
                else if (((in_C && in_B) == in_D)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S0;
                end
            end
            S5: begin
                if (&((in_C ^ in_B))) begin
                    next_state = S4;
                end
                else if ((in_B > 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S6;
                end
            end
            S6: begin
                if ((in_C != 'd1)) begin
                    next_state = S15;
                end
                else if (~((in_A || in_B))) begin
                    next_state = S0;
                end
                else if ((in_A ^ in_B)) begin
                    next_state = S5;
                end
                else if (|((in_B != in_A))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S8;
                end
            end
            S7: begin
                if (~&((in_A || in_B))) begin
                    next_state = S4;
                end
                else if (((in_A && in_B) || (in_C == in_D))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S8;
                end
            end
            S8: begin
                if ((in_A && (in_C ^ in_D))) begin
                    next_state = S14;
                end
                else begin
                    next_state = S11;
                end
            end
            S9: begin
                if ((in_C ^ in_D)) begin
                    next_state = S6;
                end
                else if (|((in_A != in_D))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S15;
                end
            end
            S10: begin
                if (((in_B ^ in_A) && in_B)) begin
                    next_state = S1;
                end
                else if ((in_D == (in_B && in_D))) begin
                    next_state = S3;
                end
                else if (~^(in_C)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S6;
                end
            end
            S11: begin
                if (((in_B == 'd1) != (in_C ^ in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S13;
                end
            end
            S12: begin
                if ((in_B == 'd0)) begin
                    next_state = S3;
                end
                else if ((in_D != 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S0;
                end
            end
            S13: begin
                if ((in_B && in_A)) begin
                    next_state = S7;
                end
                else if ((in_A && in_D)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S14;
                end
            end
            S14: begin
                if (&(in_A)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S13;
                end
            end
            S15: begin
                if ((~&(in_A) || (in_B || in_C))) begin
                    next_state = S11;
                end
                else if ((in_A != in_C)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S9;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_4_nn_16_ne_64_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_C == (in_B ^ in_C))) begin
                    next_state = S8;
                end
                else if (~|((in_A == 'd0))) begin
                    next_state = S10;
                end
                else if (((in_C == in_D) ^ (in_C && in_B))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                if ((in_A == 'd1)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S15;
                end
            end
            S2: begin
                next_state = S6;
            end
            S3: begin
                if (~&(in_D)) begin
                    next_state = S1;
                end
                else if ((in_D || (in_B != 'd1))) begin
                    next_state = S2;
                end
                else if ((in_C || in_B)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S0;
                end
            end
            S4: begin
                if (!(in_A)) begin
                    next_state = S7;
                end
                else if (((in_A ^ in_B) != 'd0)) begin
                    next_state = S10;
                end
                else if ((in_D == 'd0)) begin
                    next_state = S8;
                end
                else if ((in_A == 'd1)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S15;
                end
            end
            S5: begin
                if (!((in_A || in_D))) begin
                    next_state = S12;
                end
                else if (((in_B != 'd0) || in_A)) begin
                    next_state = S8;
                end
                else if (~(in_D)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S7;
                end
            end
            S6: begin
                if (((in_C && in_B) != 'd0)) begin
                    next_state = S14;
                end
                else if (((in_C < 'd0) && (in_D && in_C))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S1;
                end
            end
            S7: begin
                if (((in_C != in_A) != &(in_D))) begin
                    next_state = S11;
                end
                else if ((in_B ^ (in_D ^ in_C))) begin
                    next_state = S0;
                end
                else if (((in_C != in_B) == 'd1)) begin
                    next_state = S15;
                end
                else if ((in_B || in_C)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S12;
                end
            end
            S8: begin
                next_state = S2;
            end
            S9: begin
                if ((^(in_C) || ~^(in_A))) begin
                    next_state = S2;
                end
                else if (((in_D && in_A) <= in_D)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S4;
                end
            end
            S10: begin
                if ((in_A ^ in_D)) begin
                    next_state = S4;
                end
                else if (~((in_A || in_D))) begin
                    next_state = S9;
                end
                else if ((in_C < 'd1)) begin
                    next_state = S15;
                end
                else if ((in_B && (in_A == in_D))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S12;
                end
            end
            S11: begin
                if (((in_A || in_C) != in_A)) begin
                    next_state = S0;
                end
                else if ((in_B == (in_D == 'd0))) begin
                    next_state = S9;
                end
                else if ((in_A != (in_B && in_A))) begin
                    next_state = S1;
                end
                else if ((in_D && in_A)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S15;
                end
            end
            S12: begin
                if (((in_A && in_B) ^ (in_D ^ in_C))) begin
                    next_state = S11;
                end
                else if ((in_B && (in_D == 'd0))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S14;
                end
            end
            S13: begin
                next_state = S5;
            end
            S14: begin
                if ((in_D < 'd1)) begin
                    next_state = S8;
                end
                else if ((in_C || (in_B != 'd0))) begin
                    next_state = S15;
                end
                else if ((~(in_C) != 'd1)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S15: begin
                if (~(in_C)) begin
                    next_state = S3;
                end
                else if ((in_A && in_B)) begin
                    next_state = S12;
                end
                else if (((in_B != 'd1) ^ in_C)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S1;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_4_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
                next_state = S2;
            end
            S2: begin
                next_state = S0;
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_4_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                if ((in_E || !(in_J))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_4_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
            end
            S3: begin
                if (((in_M != 'd1) != 'd0)) begin
                    next_state = S0;
                end
                else if (((in_P ^ in_J) == 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_4_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
            end
            S2: begin
                next_state = S3;
            end
            S3: begin
                if (((in_N ^ in_C) || (in_M ^ in_A))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_8_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (~|(in_M)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                next_state = S3;
            end
            S2: begin
                next_state = S0;
            end
            S3: begin
                if (((in_A == in_H) != (in_D ^ in_A))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_8_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (~(|(in_J))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if (((in_G && in_A) ^ in_K)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                next_state = S0;
            end
            S3: begin
                next_state = S2;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_8_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                if ((in_I != 'd0)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                if ((in_B == 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                next_state = S0;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_8_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                if ((~^(in_B) ^ in_N)) begin
                    next_state = S2;
                end
                else if (^(in_E)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S2: begin
                next_state = S0;
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_12_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_H && in_L) ^ in_J)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if ((in_B != ~&(in_J))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                if ((in_J && in_L)) begin
                    next_state = S3;
                end
                else if (((in_C <= 'd1) != in_N)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if ((in_K == 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_12_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_D != 'd1) != in_P)) begin
                    next_state = S3;
                end
                else if ((in_B > 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                if (((in_F && in_M) == 'd0)) begin
                    next_state = S2;
                end
                else if (((in_P ^ in_I) <= in_K)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S2: begin
                if (((in_M >= 'd0) || in_J)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_12_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                if (((in_H == 'd0) == ~&(in_B))) begin
                    next_state = S0;
                end
                else if ((in_I == in_K)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                if ((!(in_D) != 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                next_state = S1;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_12_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((^(in_H) && in_J)) begin
                    next_state = S3;
                end
                else if ((in_C != 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                next_state = S2;
            end
            S2: begin
                if (((in_K != 'd0) && in_A)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                if (((in_D == 'd0) > 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_16_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_H && in_N)) begin
                    next_state = S1;
                end
                else if (((in_L ^ in_H) ^ (in_A == 'd0))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if ((in_E ^ in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S2: begin
                if (~|(in_E)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if ((in_F && in_J)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_16_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_O == in_M) == in_D)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if ((in_A == in_G)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S2: begin
                if (~|(in_J)) begin
                    next_state = S0;
                end
                else if (((in_G == in_F) == (in_K && in_A))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                if ((~(in_P) && &(in_M))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_16_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (^(in_C)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                if (~(in_N)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if ((&(in_E) || in_I)) begin
                    next_state = S3;
                end
                else if ((in_L == in_K)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if (&((in_A ^ in_D))) begin
                    next_state = S1;
                end
                else if (!((in_A != in_E))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_4_ne_16_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((~|(in_L) && (in_I == in_M))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                if (~(in_I)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S2: begin
                if (((in_H && in_O) == in_J)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if ((~&(in_F) ^ in_B)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 2;

    parameter S0 = 2'b00;
    parameter S1 = 2'b01;
    parameter S2 = 2'b10;
    parameter S3 = 2'b11;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_8_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_N || in_M)) begin
                    next_state = S2;
                end
                else if (((in_E && in_H) && (in_I || in_B))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S7;
                end
            end
            S1: begin
            end
            S2: begin
            end
            S3: begin
                if ((in_G && in_J)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S6;
                end
            end
            S4: begin
                next_state = S1;
            end
            S5: begin
            end
            S6: begin
                if (((in_G == 'd1) != in_E)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S7: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_8_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (&(in_N)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S7;
                end
            end
            S1: begin
                next_state = S6;
            end
            S2: begin
            end
            S3: begin
                next_state = S1;
            end
            S4: begin
                next_state = S5;
            end
            S5: begin
                next_state = S4;
            end
            S6: begin
                next_state = S0;
            end
            S7: begin
                next_state = S2;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_8_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S7;
            end
            S1: begin
                if ((in_M == 'd0)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S5;
                end
            end
            S2: begin
            end
            S3: begin
            end
            S4: begin
                next_state = S3;
            end
            S5: begin
                next_state = S4;
            end
            S6: begin
            end
            S7: begin
                if (((in_G != 'd0) ^ in_A)) begin
                    next_state = S0;
                end
                else if (((in_F == in_M) == 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_8_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S4;
            end
            S1: begin
            end
            S2: begin
            end
            S3: begin
                if ((in_F || (in_G ^ in_K))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S5;
                end
            end
            S4: begin
                next_state = S7;
            end
            S5: begin
            end
            S6: begin
                if ((!(in_E) || (in_K ^ in_P))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S7: begin
                if (((in_P ^ in_C) && (in_B ^ in_E))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_16_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((&(in_D) != in_G)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
            end
            S2: begin
                next_state = S7;
            end
            S3: begin
                if (((in_P && in_L) && in_C)) begin
                    next_state = S0;
                end
                else if (((in_C != 'd1) != 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
            S4: begin
                if (((in_B || in_P) != 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S5: begin
                if ((in_J < 'd1)) begin
                    next_state = S4;
                end
                else if ((in_C == 'd1)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
            S6: begin
                if ((in_G != (in_O == 'd0))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
                if (((in_K ^ in_H) != 'd1)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_16_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_C != 'd1)) begin
                    next_state = S5;
                end
                else if ((in_J != (in_I == in_E))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if (((in_G ^ in_J) == in_P)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
            end
            S3: begin
                if (((in_E || in_K) || in_E)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S2;
                end
            end
            S4: begin
                if (((in_N != in_P) < (in_A != 'd1))) begin
                    next_state = S0;
                end
                else if ((in_N || in_D)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S1;
                end
            end
            S5: begin
            end
            S6: begin
                next_state = S4;
            end
            S7: begin
                if (((in_E ^ in_M) && in_H)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_16_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                next_state = S7;
            end
            S2: begin
                next_state = S6;
            end
            S3: begin
                if (((in_A && in_F) ^ ~^(in_N))) begin
                    next_state = S4;
                end
                else if ((in_O ^ in_B)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S0;
                end
            end
            S4: begin
                next_state = S6;
            end
            S5: begin
                if ((in_C ^ in_F)) begin
                    next_state = S1;
                end
                else if ((in_C && in_P)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S6: begin
                if ((in_M == 'd0)) begin
                    next_state = S0;
                end
                else if ((in_I == in_C)) begin
                    next_state = S2;
                end
                else if ((in_B || (in_H != in_N))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S5;
                end
            end
            S7: begin
                next_state = S3;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_16_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_N && (in_D != in_G))) begin
                    next_state = S2;
                end
                else if ((in_K != 'd1)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
            S1: begin
                if ((in_C != 'd0)) begin
                    next_state = S7;
                end
                else if ((in_G != 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S4;
                end
            end
            S2: begin
                if ((in_B && in_L)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S5;
                end
            end
            S3: begin
                next_state = S4;
            end
            S4: begin
                if ((in_F || in_L)) begin
                    next_state = S1;
                end
                else if ((in_E == in_G)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S6;
                end
            end
            S5: begin
                if ((in_M == 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S6;
                end
            end
            S6: begin
                next_state = S4;
            end
            S7: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_24_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_D ^ in_J)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S2;
                end
            end
            S1: begin
                if ((in_O != 'd1)) begin
                    next_state = S5;
                end
                else if (~&((in_N ^ in_O))) begin
                    next_state = S0;
                end
                else if ((in_I == 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S4;
                end
            end
            S2: begin
                if (^(in_I)) begin
                    next_state = S1;
                end
                else if ((|(in_L) == 'd0)) begin
                    next_state = S4;
                end
                else if (~(in_I)) begin
                    next_state = S7;
                end
                else if ((in_F <= (in_A >= 'd1))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S5;
                end
            end
            S3: begin
                if (((in_K && in_I) ^ in_N)) begin
                    next_state = S6;
                end
                else if ((in_P && (in_B ^ in_M))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S7;
                end
            end
            S4: begin
            end
            S5: begin
                next_state = S2;
            end
            S6: begin
                if (((in_F || in_G) || (in_H ^ in_F))) begin
                    next_state = S3;
                end
                else if (((in_G == 'd0) < 'd1)) begin
                    next_state = S7;
                end
                else if (((in_O && in_A) && (in_C || in_A))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S4;
                end
            end
            S7: begin
                if ((in_F ^ (in_L < in_J))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S2;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_24_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S1;
            end
            S1: begin
                if ((in_F == 'd1)) begin
                    next_state = S2;
                end
                else if (((in_L ^ in_I) ^ in_K)) begin
                    next_state = S4;
                end
                else if (((in_E ^ in_I) ^ (in_L == 'd0))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
                if (((in_F ^ in_K) ^ (in_E && in_K))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                if (((in_P ^ in_J) || in_P)) begin
                    next_state = S5;
                end
                else if (((in_P <= 'd1) != 'd0)) begin
                    next_state = S4;
                end
                else if (((in_F < in_D) || (in_L != 'd1))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S1;
                end
            end
            S4: begin
                if (((in_C ^ in_O) == 'd0)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S7;
                end
            end
            S5: begin
                next_state = S0;
            end
            S6: begin
                if (((in_A == 'd0) ^ (in_D ^ in_M))) begin
                    next_state = S1;
                end
                else if (|(in_L)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
                if ((in_D ^ ~&(in_L))) begin
                    next_state = S3;
                end
                else if (((in_C && in_H) ^ in_C)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S5;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_24_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_H == 'd0) || (in_F != in_O))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S6;
                end
            end
            S1: begin
                if (~|((in_N != 'd0))) begin
                    next_state = S0;
                end
                else if (&((in_I == in_A))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S4;
                end
            end
            S2: begin
                if ((in_F <= (in_I == 'd1))) begin
                    next_state = S3;
                end
                else if (((in_H > in_D) && (in_C || in_M))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S0;
                end
            end
            S3: begin
                next_state = S4;
            end
            S4: begin
                if (&(in_P)) begin
                    next_state = S6;
                end
                else if (((in_C && in_H) || (in_B || in_K))) begin
                    next_state = S5;
                end
                else if ((~^(in_E) != 'd1)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S5: begin
                if (((in_B == in_J) || in_I)) begin
                    next_state = S2;
                end
                else if ((in_I != 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S3;
                end
            end
            S6: begin
                if ((in_B != 'd0)) begin
                    next_state = S1;
                end
                else if (((in_K >= in_O) == (in_A || in_J))) begin
                    next_state = S7;
                end
                else if (((in_O ^ in_C) || in_J)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
                next_state = S5;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_24_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_K != 'd1)) begin
                    next_state = S4;
                end
                else if ((in_C || ~^(in_D))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S7;
                end
            end
            S1: begin
                if (((in_C != 'd0) ^ |(in_L))) begin
                    next_state = S0;
                end
                else if (~(in_E)) begin
                    next_state = S3;
                end
                else if ((in_H != 'd0)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S5;
                end
            end
            S2: begin
                next_state = S3;
            end
            S3: begin
                if (((in_N && in_M) != 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S4: begin
                if ((in_B && (in_F ^ in_B))) begin
                    next_state = S1;
                end
                else if ((in_K == in_A)) begin
                    next_state = S2;
                end
                else if (((in_E == 'd0) ^ (in_K != in_P))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S5;
                end
            end
            S5: begin
                next_state = S4;
            end
            S6: begin
                if ((~^(in_M) && in_G)) begin
                    next_state = S3;
                end
                else if (((in_I || in_E) != in_A)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S2;
                end
            end
            S7: begin
                if (((in_J == 'd1) == 'd1)) begin
                    next_state = S3;
                end
                else if ((in_I > 'd1)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_32_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_N ^ in_O) || (in_M && in_K))) begin
                    next_state = S3;
                end
                else if ((in_M && in_D)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                next_state = S7;
            end
            S2: begin
                if (((in_B || in_F) == 'd0)) begin
                    next_state = S0;
                end
                else if (((in_N ^ in_L) != 'd0)) begin
                    next_state = S1;
                end
                else if ((~&(in_I) ^ (in_J || in_F))) begin
                    next_state = S7;
                end
                else if (((in_L && in_B) ^ in_A)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S6;
                end
            end
            S3: begin
                if ((in_J == 'd0)) begin
                    next_state = S0;
                end
                else if ((in_K && &(in_G))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S2;
                end
            end
            S4: begin
                if ((in_M || in_K)) begin
                    next_state = S2;
                end
                else if (~^((in_P == 'd0))) begin
                    next_state = S6;
                end
                else if ((in_J != 'd1)) begin
                    next_state = S5;
                end
                else if (((in_O != 'd0) == (in_I != 'd1))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S1;
                end
            end
            S5: begin
                if (((in_C != 'd0) == 'd1)) begin
                    next_state = S4;
                end
                else if ((in_C ^ in_F)) begin
                    next_state = S1;
                end
                else if ((in_H || (in_F ^ in_N))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S6;
                end
            end
            S6: begin
                if ((in_F == 'd0)) begin
                    next_state = S5;
                end
                else if (~&((in_C == 'd0))) begin
                    next_state = S7;
                end
                else if (((in_D || in_C) ^ (in_O && in_G))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S3;
                end
            end
            S7: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_32_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
                if ((in_E ^ (in_I <= 'd1))) begin
                    next_state = S0;
                end
                else if (&((in_L ^ in_J))) begin
                    next_state = S4;
                end
                else if ((|(in_I) == 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
                if (~|(in_E)) begin
                    next_state = S1;
                end
                else if ((in_C == in_H)) begin
                    next_state = S6;
                end
                else if (((in_M != in_B) || (in_L || in_F))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                if (((in_G != 'd0) || ~&(in_D))) begin
                    next_state = S5;
                end
                else if (((in_J && in_C) == 'd0)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S7;
                end
            end
            S4: begin
                if ((in_H || (in_L == in_J))) begin
                    next_state = S3;
                end
                else if ((~^(in_F) != 'd1)) begin
                    next_state = S2;
                end
                else if (&(!(in_K))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S6;
                end
            end
            S5: begin
                if ((~&(in_K) == in_E)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S1;
                end
            end
            S6: begin
                next_state = S7;
            end
            S7: begin
                if ((in_N && in_M)) begin
                    next_state = S2;
                end
                else if (((in_F ^ in_G) != 'd0)) begin
                    next_state = S1;
                end
                else if (((in_A || in_M) != 'd1)) begin
                    next_state = S0;
                end
                else if (((in_D == 'd1) == 'd0)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_32_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_A == in_J) ^ (in_L || in_E))) begin
                    next_state = S6;
                end
                else if ((in_E && ~(in_N))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S3;
                end
            end
            S1: begin
                if ((in_C > 'd0)) begin
                    next_state = S0;
                end
                else if (&((in_L != in_C))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S4;
                end
            end
            S2: begin
                if (~&(in_K)) begin
                    next_state = S5;
                end
                else if ((in_P && (in_B || in_M))) begin
                    next_state = S3;
                end
                else if ((in_O <= 'd1)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S4;
                end
            end
            S3: begin
                next_state = S5;
            end
            S4: begin
                if ((in_A && (in_F && in_I))) begin
                    next_state = S1;
                end
                else if ((in_K && in_J)) begin
                    next_state = S2;
                end
                else if (((in_N ^ in_P) != 'd0)) begin
                    next_state = S3;
                end
                else if ((in_F != ~|(in_P))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S0;
                end
            end
            S5: begin
                if ((in_H != &(in_B))) begin
                    next_state = S4;
                end
                else if (((in_N || in_D) || (in_G ^ in_O))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S7;
                end
            end
            S6: begin
                if (~|((in_N || in_J))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S0;
                end
            end
            S7: begin
                if (((in_D == in_I) != 'd1)) begin
                    next_state = S0;
                end
                else if ((in_L || in_E)) begin
                    next_state = S4;
                end
                else if ((in_P && in_D)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_8_ne_32_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_D || (in_H != 'd0))) begin
                    next_state = S6;
                end
                else if (^(in_B)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                if (((in_G || in_M) || in_I)) begin
                    next_state = S0;
                end
                else if ((in_N || (in_J ^ in_P))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S4;
                end
            end
            S2: begin
                next_state = S5;
            end
            S3: begin
                if (~((in_B || in_J))) begin
                    next_state = S1;
                end
                else if (((in_G || in_P) >= 'd0)) begin
                    next_state = S4;
                end
                else if ((in_C && in_G)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S7;
                end
            end
            S4: begin
                if ((in_G && in_M)) begin
                    next_state = S3;
                end
                else if (((in_N && in_G) != ~&(in_M))) begin
                    next_state = S7;
                end
                else if (^(in_F)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S6;
                end
            end
            S5: begin
                next_state = S6;
            end
            S6: begin
                if (~|((in_A != 'd1))) begin
                    next_state = S4;
                end
                else if (((in_I == 'd0) ^ in_P)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S7: begin
                if ((in_E != 'd0)) begin
                    next_state = S2;
                end
                else if (((in_K == in_F) ^ in_D)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 3;

    parameter S0 = 3'b000;
    parameter S1 = 3'b001;
    parameter S2 = 3'b010;
    parameter S3 = 3'b011;
    parameter S4 = 3'b100;
    parameter S5 = 3'b101;
    parameter S6 = 3'b110;
    parameter S7 = 3'b111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_16_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S2;
            end
            S1: begin
                if (((in_O || in_H) && in_A)) begin
                    next_state = S2;
                end
                else if (^(in_K)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S10;
                end
            end
            S2: begin
                next_state = S5;
            end
            S3: begin
                next_state = S1;
            end
            S4: begin
            end
            S5: begin
                next_state = S12;
            end
            S6: begin
                next_state = S9;
            end
            S7: begin
            end
            S8: begin
                if (((in_E == 'd1) && in_H)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S15;
                end
            end
            S9: begin
                next_state = S4;
            end
            S10: begin
                next_state = S14;
            end
            S11: begin
                next_state = S3;
            end
            S12: begin
            end
            S13: begin
                if (((in_A ^ in_F) != (in_D != in_H))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S8;
                end
            end
            S14: begin
            end
            S15: begin
                if (~^(in_J)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S11;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_16_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S7;
            end
            S1: begin
                if (~|((in_E < 'd0))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S11;
                end
            end
            S2: begin
                next_state = S5;
            end
            S3: begin
            end
            S4: begin
                if ((in_I ^ (in_K != 'd0))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S14;
                end
            end
            S5: begin
                next_state = S13;
            end
            S6: begin
            end
            S7: begin
                if ((in_C >= 'd1)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S12;
                end
            end
            S8: begin
                next_state = S6;
            end
            S9: begin
                next_state = S2;
            end
            S10: begin
                next_state = S8;
            end
            S11: begin
                if ((in_D > 'd0)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S4;
                end
            end
            S12: begin
                next_state = S7;
            end
            S13: begin
            end
            S14: begin
                if ((|(in_G) ^ in_N)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S15;
                end
            end
            S15: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_16_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S9;
            end
            S1: begin
            end
            S2: begin
            end
            S3: begin
                if (((in_J == 'd1) > 'd0)) begin
                    next_state = S5;
                end
                else if ((in_J ^ (in_P != 'd1))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S13;
                end
            end
            S4: begin
                next_state = S6;
            end
            S5: begin
                next_state = S1;
            end
            S6: begin
            end
            S7: begin
                next_state = S15;
            end
            S8: begin
                next_state = S0;
            end
            S9: begin
            end
            S10: begin
                next_state = S7;
            end
            S11: begin
                if (((in_L == in_M) ^ in_E)) begin
                    next_state = S3;
                end
                else if (((in_C < 'd1) == 'd0)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S10;
                end
            end
            S12: begin
            end
            S13: begin
                if (!((in_M == in_K))) begin
                    next_state = S2;
                end
                else if ((in_N != 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S11;
                end
            end
            S14: begin
            end
            S15: begin
                next_state = S14;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_16_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((~&(in_D) != in_A)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S13;
                end
            end
            S1: begin
            end
            S2: begin
            end
            S3: begin
                if (((in_I != 'd0) == 'd1)) begin
                    next_state = S0;
                end
                else if ((in_J != 'd0)) begin
                    next_state = S1;
                end
                else if (|(in_I)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S11;
                end
            end
            S4: begin
                next_state = S15;
            end
            S5: begin
                next_state = S14;
            end
            S6: begin
            end
            S7: begin
                next_state = S3;
            end
            S8: begin
                next_state = S7;
            end
            S9: begin
            end
            S10: begin
                if (~&(in_J)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S8;
                end
            end
            S11: begin
                next_state = S12;
            end
            S12: begin
                if (~&((in_B > 'd0))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S6;
                end
            end
            S13: begin
            end
            S14: begin
                next_state = S9;
            end
            S15: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_32_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S6;
            end
            S1: begin
                if (((in_M && in_H) > 'd1)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S9;
                end
            end
            S2: begin
                if ((in_E || !(in_M))) begin
                    next_state = S4;
                end
                else if ((in_A != (in_L != 'd1))) begin
                    next_state = S5;
                end
                else if ((in_C == 'd1)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S13;
                end
            end
            S3: begin
                if (!(in_B)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S1;
                end
            end
            S4: begin
                if (~&(in_C)) begin
                    next_state = S0;
                end
                else if (~|(in_E)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S11;
                end
            end
            S5: begin
                if (((in_H ^ in_O) != 'd0)) begin
                    next_state = S12;
                end
                else if ((^(in_E) < 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S0;
                end
            end
            S6: begin
                if (((in_L ^ in_K) == 'd0)) begin
                    next_state = S3;
                end
                else if (|((in_L ^ in_I))) begin
                    next_state = S9;
                end
                else if ((~&(in_C) && in_D)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S10;
                end
            end
            S7: begin
                if ((in_I == 'd0)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S15;
                end
            end
            S8: begin
                if ((in_N ^ ~^(in_H))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S3;
                end
            end
            S9: begin
            end
            S10: begin
                next_state = S5;
            end
            S11: begin
                next_state = S15;
            end
            S12: begin
                if (|((in_G && in_I))) begin
                    next_state = S3;
                end
                else if (~((in_J && in_A))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S9;
                end
            end
            S13: begin
                if ((in_M || in_C)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S5;
                end
            end
            S14: begin
            end
            S15: begin
                if (((in_E != in_F) || in_E)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S14;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_32_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
                if (&(in_B)) begin
                    next_state = S9;
                end
                else if ((in_N && in_C)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S15;
                end
            end
            S2: begin
                if (((in_M != 'd0) || in_H)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S15;
                end
            end
            S3: begin
                if (~|((in_A <= 'd1))) begin
                    next_state = S10;
                end
                else begin
                    next_state = S13;
                end
            end
            S4: begin
                if ((in_I != 'd0)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S13;
                end
            end
            S5: begin
                next_state = S12;
            end
            S6: begin
                next_state = S5;
            end
            S7: begin
                if (((in_K || in_P) && in_K)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S1;
                end
            end
            S8: begin
                if ((in_K && in_O)) begin
                    next_state = S11;
                end
                else if (((in_D || in_P) != 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S15;
                end
            end
            S9: begin
                if (((in_O == 'd0) || (in_F || in_H))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S3;
                end
            end
            S10: begin
            end
            S11: begin
                if (((in_A >= 'd0) && (in_E ^ in_B))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S7;
                end
            end
            S12: begin
                next_state = S15;
            end
            S13: begin
                if ((~(in_K) != (in_C == 'd0))) begin
                    next_state = S5;
                end
                else if ((in_C == in_B)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S3;
                end
            end
            S14: begin
                if (((in_F || in_O) || in_M)) begin
                    next_state = S1;
                end
                else if (|((in_L ^ in_H))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S2;
                end
            end
            S15: begin
                if (((in_G || in_F) < in_M)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S9;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_32_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S3;
            end
            S1: begin
                if ((^(in_N) == 'd0)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S15;
                end
            end
            S2: begin
                if (~|(in_L)) begin
                    next_state = S6;
                end
                else if (((in_M || in_B) && (in_I ^ in_K))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S3;
                end
            end
            S3: begin
                if ((in_M == 'd1)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S7;
                end
            end
            S4: begin
                if (((in_C ^ in_J) && (in_D != 'd0))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S0;
                end
            end
            S5: begin
                next_state = S4;
            end
            S6: begin
                if (~^(in_H)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S14;
                end
            end
            S7: begin
                next_state = S10;
            end
            S8: begin
            end
            S9: begin
                if (((in_B == 'd1) != in_D)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S15;
                end
            end
            S10: begin
                next_state = S11;
            end
            S11: begin
                if ((in_O != 'd1)) begin
                    next_state = S4;
                end
                else if (^(&(in_M))) begin
                    next_state = S5;
                end
                else if (~|((in_O == 'd0))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S2;
                end
            end
            S12: begin
                if (!((in_N != in_E))) begin
                    next_state = S15;
                end
                else if (((in_K && in_G) || in_E)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S4;
                end
            end
            S13: begin
                if ((in_G == ~^(in_I))) begin
                    next_state = S0;
                end
                else if ((in_I == in_G)) begin
                    next_state = S9;
                end
                else if (((in_F != 'd1) < in_H)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S3;
                end
            end
            S14: begin
                if (((in_I == 'd0) != 'd1)) begin
                    next_state = S1;
                end
                else if ((in_H == in_D)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S12;
                end
            end
            S15: begin
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_32_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((~^(in_F) != (in_M && in_H))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S15;
                end
            end
            S1: begin
                next_state = S12;
            end
            S2: begin
                if ((in_I && in_O)) begin
                    next_state = S11;
                end
                else if (((in_H || in_C) >= in_I)) begin
                    next_state = S14;
                end
                else if ((|(in_L) >= (in_J && in_O))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S15;
                end
            end
            S3: begin
                if ((in_F == 'd0)) begin
                    next_state = S1;
                end
                else if (((in_B ^ in_F) != 'd1)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S6;
                end
            end
            S4: begin
                next_state = S15;
            end
            S5: begin
            end
            S6: begin
                if ((in_C != 'd0)) begin
                    next_state = S3;
                end
                else if ((in_B && in_E)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S10;
                end
            end
            S7: begin
                if ((in_K || in_D)) begin
                    next_state = S9;
                end
                else if (^(in_G)) begin
                    next_state = S4;
                end
                else if ((in_N == in_B)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S8;
                end
            end
            S8: begin
                next_state = S5;
            end
            S9: begin
                next_state = S10;
            end
            S10: begin
                if (!(!(in_K))) begin
                    next_state = S4;
                end
                else if ((in_B ^ ~|(in_N))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S3;
                end
            end
            S11: begin
                next_state = S10;
            end
            S12: begin
                next_state = S13;
            end
            S13: begin
            end
            S14: begin
                if ((~&(in_D) || in_F)) begin
                    next_state = S8;
                end
                else if (((in_F == 'd0) == in_L)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S4;
                end
            end
            S15: begin
                if ((in_O && (in_C ^ in_H))) begin
                    next_state = S0;
                end
                else begin
                    next_state = S6;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_48_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_H == 'd0)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S7;
                end
            end
            S1: begin
                if ((in_O == 'd0)) begin
                    next_state = S7;
                end
                else if ((!(in_E) >= in_F)) begin
                    next_state = S4;
                end
                else if (~(in_H)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
                if ((in_C == 'd1)) begin
                    next_state = S9;
                end
                else if ((in_H == in_D)) begin
                    next_state = S10;
                end
                else if (((in_H == 'd1) != in_F)) begin
                    next_state = S14;
                end
                else if (((in_J != in_I) == 'd0)) begin
                    next_state = S0;
                end
                else if (!(in_A)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S8;
                end
            end
            S3: begin
            end
            S4: begin
                next_state = S0;
            end
            S5: begin
                if ((in_K == 'd0)) begin
                    next_state = S3;
                end
                else if (((in_N == 'd1) || in_K)) begin
                    next_state = S6;
                end
                else if ((in_O == 'd1)) begin
                    next_state = S12;
                end
                else if (~((in_D == 'd0))) begin
                    next_state = S2;
                end
                else if (((in_G || in_M) == 'd1)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S14;
                end
            end
            S6: begin
                if ((in_P == in_K)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S5;
                end
            end
            S7: begin
                if ((in_G == ~(in_I))) begin
                    next_state = S2;
                end
                else if ((in_G && in_D)) begin
                    next_state = S12;
                end
                else if (((in_P != in_F) == 'd1)) begin
                    next_state = S9;
                end
                else if ((!(in_J) ^ in_D)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S10;
                end
            end
            S8: begin
                if ((in_C == 'd0)) begin
                    next_state = S15;
                end
                else if (((in_B == 'd0) <= 'd1)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S14;
                end
            end
            S9: begin
                next_state = S7;
            end
            S10: begin
                if (~|(in_M)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S5;
                end
            end
            S11: begin
                if (((in_G && in_N) || in_B)) begin
                    next_state = S13;
                end
                else if ((in_I && in_M)) begin
                    next_state = S4;
                end
                else if ((in_B || in_E)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S7;
                end
            end
            S12: begin
                if ((in_N == 'd0)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S1;
                end
            end
            S13: begin
                next_state = S5;
            end
            S14: begin
                if ((|(in_G) || in_K)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S6;
                end
            end
            S15: begin
                if (((in_L || in_B) == 'd0)) begin
                    next_state = S1;
                end
                else if ((in_C != 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S11;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_48_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S6;
            end
            S1: begin
                next_state = S12;
            end
            S2: begin
                if ((!(in_L) || in_I)) begin
                    next_state = S8;
                end
                else if ((in_J || in_A)) begin
                    next_state = S6;
                end
                else if (((in_F ^ in_C) == 'd1)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S4;
                end
            end
            S3: begin
                if (((in_O || in_J) && (in_L || in_I))) begin
                    next_state = S9;
                end
                else if ((in_M && in_A)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S14;
                end
            end
            S4: begin
                next_state = S10;
            end
            S5: begin
                if ((in_G || (in_A && in_F))) begin
                    next_state = S3;
                end
                else if (^(in_B)) begin
                    next_state = S15;
                end
                else if ((in_I == 'd0)) begin
                    next_state = S14;
                end
                else if (~|(~|(in_H))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S4;
                end
            end
            S6: begin
                if ((in_B == in_G)) begin
                    next_state = S0;
                end
                else if (((in_C != 'd0) ^ ~&(in_L))) begin
                    next_state = S15;
                end
                else if (((in_I ^ in_M) != 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S8;
                end
            end
            S7: begin
                if (&(in_G)) begin
                    next_state = S14;
                end
                else if ((in_N == ~(in_P))) begin
                    next_state = S5;
                end
                else if (((in_I ^ in_L) && (in_N || in_K))) begin
                    next_state = S6;
                end
                else if ((in_P == 'd0)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S12;
                end
            end
            S8: begin
                if (((in_K || in_D) ^ in_K)) begin
                    next_state = S4;
                end
                else if (~^((in_E && in_A))) begin
                    next_state = S6;
                end
                else if (~|((in_O < 'd0))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S9;
                end
            end
            S9: begin
                if ((~^(in_H) != &(in_N))) begin
                    next_state = S11;
                end
                else if (((in_C || in_O) || in_D)) begin
                    next_state = S4;
                end
                else if (~((in_M && in_D))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S6;
                end
            end
            S10: begin
                if (~((in_J || in_E))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S12;
                end
            end
            S11: begin
                next_state = S7;
            end
            S12: begin
                if ((in_N && in_C)) begin
                    next_state = S7;
                end
                else if ((in_N ^ in_B)) begin
                    next_state = S3;
                end
                else if ((in_C && (in_G != 'd0))) begin
                    next_state = S4;
                end
                else if (((in_N != in_D) ^ in_I)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S11;
                end
            end
            S13: begin
            end
            S14: begin
                if ((in_I != 'd0)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S1;
                end
            end
            S15: begin
                if (((in_H ^ in_C) <= 'd0)) begin
                    next_state = S0;
                end
                else if ((in_H && (in_A || in_P))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S5;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_48_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_B == 'd1)) begin
                    next_state = S3;
                end
                else if (((in_M != in_E) != in_M)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S15;
                end
            end
            S1: begin
                if (((in_E ^ in_F) ^ (in_M || in_C))) begin
                    next_state = S8;
                end
                else if ((in_D && in_H)) begin
                    next_state = S0;
                end
                else if ((~&(in_E) && in_M)) begin
                    next_state = S15;
                end
                else if ((in_O ^ in_A)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S3;
                end
            end
            S2: begin
                if ((in_O != 'd0)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S1;
                end
            end
            S3: begin
                if (~^((in_N || in_F))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S4;
                end
            end
            S4: begin
                if (~^(in_B)) begin
                    next_state = S0;
                end
                else if (((in_J ^ in_M) != 'd0)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S10;
                end
            end
            S5: begin
                if ((in_P && in_I)) begin
                    next_state = S14;
                end
                else if (((in_K == 'd1) && in_L)) begin
                    next_state = S9;
                end
                else if (((in_K <= 'd0) != 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S0;
                end
            end
            S6: begin
            end
            S7: begin
                if ((in_O != in_A)) begin
                    next_state = S9;
                end
                else if ((in_L || ~&(in_E))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S5;
                end
            end
            S8: begin
                if (((in_D ^ in_F) != 'd1)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S12;
                end
            end
            S9: begin
                if (!(in_A)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S4;
                end
            end
            S10: begin
                next_state = S5;
            end
            S11: begin
                if ((~|(in_G) == 'd1)) begin
                    next_state = S9;
                end
                else if ((in_M == 'd0)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S5;
                end
            end
            S12: begin
                if (~((in_B != in_O))) begin
                    next_state = S15;
                end
                else if ((in_G <= in_H)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S9;
                end
            end
            S13: begin
                next_state = S12;
            end
            S14: begin
                if (~&((in_C == in_K))) begin
                    next_state = S2;
                end
                else if (((in_I && in_H) == 'd0)) begin
                    next_state = S6;
                end
                else if (((in_A != in_M) ^ in_F)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S15;
                end
            end
            S15: begin
                if (((in_F && in_M) == 'd0)) begin
                    next_state = S4;
                end
                else if ((in_P && (in_N == 'd1))) begin
                    next_state = S7;
                end
                else if ((in_N != (in_O && in_B))) begin
                    next_state = S10;
                end
                else if ((in_H > 'd0)) begin
                    next_state = S3;
                end
                else if (&((in_A == 'd1))) begin
                    next_state = S14;
                end
                else begin
                    next_state = S5;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_48_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                next_state = S11;
            end
            S1: begin
                if ((in_B == (in_G ^ in_A))) begin
                    next_state = S14;
                end
                else if ((in_L != 'd0)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S6;
                end
            end
            S2: begin
                if (((in_J == 'd1) == in_M)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S14;
                end
            end
            S3: begin
                if (~&(in_G)) begin
                    next_state = S2;
                end
                else if (~|(in_M)) begin
                    next_state = S10;
                end
                else if (|(in_A)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S15;
                end
            end
            S4: begin
                if ((in_M ^ (in_J && in_C))) begin
                    next_state = S5;
                end
                else if ((|(in_A) ^ in_B)) begin
                    next_state = S8;
                end
                else if (((in_E ^ in_I) > (in_D ^ in_L))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S1;
                end
            end
            S5: begin
                if (((in_M != 'd1) && (in_I || in_E))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S10;
                end
            end
            S6: begin
                if ((in_M ^ (in_O || in_J))) begin
                    next_state = S8;
                end
                else if (((in_M ^ in_K) && in_E)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S9;
                end
            end
            S7: begin
                if ((in_K == 'd1)) begin
                    next_state = S0;
                end
                else if (((in_G || in_K) == 'd0)) begin
                    next_state = S3;
                end
                else if (((in_F && in_M) != 'd0)) begin
                    next_state = S4;
                end
                else if (~^((in_F && in_E))) begin
                    next_state = S9;
                end
                else if (((in_L > 'd0) > 'd1)) begin
                    next_state = S14;
                end
                else if (~^(in_C)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S1;
                end
            end
            S8: begin
                if (~|(in_M)) begin
                    next_state = S11;
                end
                else if (~^((in_N ^ in_E))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S2;
                end
            end
            S9: begin
                if (|((in_F || in_O))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S15;
                end
            end
            S10: begin
                if (!(in_P)) begin
                    next_state = S1;
                end
                else begin
                    next_state = S2;
                end
            end
            S11: begin
                if (^(in_D)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S8;
                end
            end
            S12: begin
                if (|(in_F)) begin
                    next_state = S6;
                end
                else if (!(in_G)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S10;
                end
            end
            S13: begin
                next_state = S15;
            end
            S14: begin
                if ((~|(in_F) && in_B)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S15;
                end
            end
            S15: begin
                next_state = S7;
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_64_wd_32_opd_2_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_L != 'd1)) begin
                    next_state = S5;
                end
                else if (((in_N == 'd1) == 'd1)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S1;
                end
            end
            S1: begin
                if ((~(in_A) <= 'd1)) begin
                    next_state = S7;
                end
                else if (((in_E || in_M) && in_F)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S9;
                end
            end
            S2: begin
                if (((in_D < in_E) > 'd1)) begin
                    next_state = S6;
                end
                else if ((in_P || in_C)) begin
                    next_state = S11;
                end
                else if (((in_G ^ in_M) != 'd1)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S13;
                end
            end
            S3: begin
                if (((in_B && in_O) != 'd1)) begin
                    next_state = S12;
                end
                else if ((in_I || in_A)) begin
                    next_state = S1;
                end
                else if (((in_N != 'd0) != in_A)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S14;
                end
            end
            S4: begin
                if ((~(in_P) && (in_M ^ in_E))) begin
                    next_state = S0;
                end
                else if ((in_K <= 'd0)) begin
                    next_state = S2;
                end
                else if (~((in_N >= 'd0))) begin
                    next_state = S9;
                end
                else if ((in_B ^ in_P)) begin
                    next_state = S11;
                end
                else if ((in_N > in_J)) begin
                    next_state = S7;
                end
                else if (((in_J && in_A) || in_M)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S8;
                end
            end
            S5: begin
                if ((~(in_N) || ~^(in_O))) begin
                    next_state = S10;
                end
                else if ((~|(in_P) >= (in_I == in_A))) begin
                    next_state = S4;
                end
                else if ((~(in_N) ^ (in_J == in_I))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S6;
                end
            end
            S6: begin
                next_state = S11;
            end
            S7: begin
                if ((^(in_L) == 'd1)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S15;
                end
            end
            S8: begin
                if ((in_M != (in_E ^ in_K))) begin
                    next_state = S15;
                end
                else if (((in_I != 'd0) == 'd1)) begin
                    next_state = S7;
                end
                else if ((in_P ^ ~|(in_B))) begin
                    next_state = S13;
                end
                else if ((in_F == 'd1)) begin
                    next_state = S5;
                end
                else begin
                    next_state = S10;
                end
            end
            S9: begin
                if ((in_B ^ in_M)) begin
                    next_state = S1;
                end
                else if (((in_O != 'd0) ^ in_L)) begin
                    next_state = S3;
                end
                else if ((in_D ^ (in_J ^ in_H))) begin
                    next_state = S14;
                end
                else if (((in_A || in_F) || (in_D != in_J))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S11;
                end
            end
            S10: begin
                if (((in_E ^ in_C) && in_P)) begin
                    next_state = S4;
                end
                else if ((&(in_L) != (in_N == in_I))) begin
                    next_state = S3;
                end
                else if ((in_M ^ in_O)) begin
                    next_state = S5;
                end
                else if ((&(in_H) || in_G)) begin
                    next_state = S0;
                end
                else if ((in_G || in_K)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S13;
                end
            end
            S11: begin
                if (~((in_L == 'd1))) begin
                    next_state = S14;
                end
                else if (~|(in_M)) begin
                    next_state = S15;
                end
                else if (((in_M && in_F) && in_M)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S5;
                end
            end
            S12: begin
                if ((&(in_M) == 'd0)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S4;
                end
            end
            S13: begin
            end
            S14: begin
                if (((in_N || in_D) || in_P)) begin
                    next_state = S13;
                end
                else if ((in_A == 'd1)) begin
                    next_state = S15;
                end
                else if ((in_M == 'd0)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S0;
                end
            end
            S15: begin
                if ((~^(in_F) == 'd1)) begin
                    next_state = S8;
                end
                else if ((^(in_N) < 'd1)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S0;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_64_wd_32_opd_3_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_J && in_H) == in_B)) begin
                    next_state = S4;
                end
                else if (^(in_O)) begin
                    next_state = S8;
                end
                else if (~((in_G != 'd0))) begin
                    next_state = S13;
                end
                else if ((in_J || (in_H ^ in_L))) begin
                    next_state = S1;
                end
                else if ((~&(in_I) ^ (in_D == in_K))) begin
                    next_state = S11;
                end
                else if (((in_G || in_D) && ^(in_M))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S9;
                end
            end
            S1: begin
                if (((in_K && in_C) >= 'd1)) begin
                    next_state = S0;
                end
                else if ((in_C < in_D)) begin
                    next_state = S9;
                end
                else if ((in_I || ~&(in_J))) begin
                    next_state = S2;
                end
                else begin
                    next_state = S15;
                end
            end
            S2: begin
                if (!((in_N || in_A))) begin
                    next_state = S8;
                end
                else if ((in_L < 'd1)) begin
                    next_state = S6;
                end
                else if (((in_N != 'd0) && (in_K ^ in_M))) begin
                    next_state = S4;
                end
                else begin
                    next_state = S14;
                end
            end
            S3: begin
            end
            S4: begin
                if (((in_E != in_H) != 'd0)) begin
                    next_state = S3;
                end
                else if ((in_F ^ |(in_B))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S14;
                end
            end
            S5: begin
                if (((in_P != 'd1) == 'd0)) begin
                    next_state = S3;
                end
                else if ((in_N && in_E)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S12;
                end
            end
            S6: begin
                if (((in_H >= 'd1) >= 'd0)) begin
                    next_state = S7;
                end
                else if ((in_M > 'd0)) begin
                    next_state = S12;
                end
                else if ((~&(in_I) <= 'd0)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S4;
                end
            end
            S7: begin
                if ((in_O == (in_A != 'd0))) begin
                    next_state = S11;
                end
                else if ((in_H && in_P)) begin
                    next_state = S0;
                end
                else begin
                    next_state = S5;
                end
            end
            S8: begin
                if ((in_C && (in_P < 'd1))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S15;
                end
            end
            S9: begin
                next_state = S2;
            end
            S10: begin
                if ((in_B && in_G)) begin
                    next_state = S14;
                end
                else if (^(in_L)) begin
                    next_state = S8;
                end
                else if ((in_K != 'd1)) begin
                    next_state = S3;
                end
                else if (!(~(in_J))) begin
                    next_state = S12;
                end
                else if (((in_E && in_J) ^ ~(in_H))) begin
                    next_state = S5;
                end
                else begin
                    next_state = S7;
                end
            end
            S11: begin
                if (~|(in_D)) begin
                    next_state = S15;
                end
                else if ((in_I && (in_P == in_B))) begin
                    next_state = S12;
                end
                else if ((in_N ^ (in_D && in_P))) begin
                    next_state = S6;
                end
                else if ((in_F == 'd0)) begin
                    next_state = S13;
                end
                else if ((in_E >= 'd0)) begin
                    next_state = S7;
                end
                else begin
                    next_state = S8;
                end
            end
            S12: begin
                if (((in_I != in_H) ^ in_G)) begin
                    next_state = S9;
                end
                else if ((in_I != 'd0)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S1;
                end
            end
            S13: begin
                if (((in_M != in_O) && (in_P != 'd1))) begin
                    next_state = S10;
                end
                else begin
                    next_state = S15;
                end
            end
            S14: begin
                if (~(in_D)) begin
                    next_state = S6;
                end
                else if ((in_I ^ (in_G == in_M))) begin
                    next_state = S5;
                end
                else if (((in_O && in_F) && in_E)) begin
                    next_state = S15;
                end
                else if (((in_K == 'd0) != 'd1)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S8;
                end
            end
            S15: begin
                if ((in_M || (in_F == 'd0))) begin
                    next_state = S1;
                end
                else if ((in_P == 'd0)) begin
                    next_state = S2;
                end
                else if (~^((in_G && in_E))) begin
                    next_state = S8;
                end
                else if ((^(in_B) != 'd1)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S14;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_64_wd_32_opd_4_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if (((in_M != 'd1) ^ in_A)) begin
                    next_state = S8;
                end
                else if (((in_P || in_L) || in_A)) begin
                    next_state = S3;
                end
                else if ((in_G ^ ~(in_H))) begin
                    next_state = S5;
                end
                else if (^((in_I && in_A))) begin
                    next_state = S1;
                end
                else begin
                    next_state = S10;
                end
            end
            S1: begin
                if ((in_O && in_C)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S13;
                end
            end
            S2: begin
                next_state = S1;
            end
            S3: begin
                if (~&(in_N)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S5;
                end
            end
            S4: begin
                if ((in_A || ~|(in_N))) begin
                    next_state = S14;
                end
                else if (((in_O && in_P) && in_B)) begin
                    next_state = S6;
                end
                else if (~((in_O || in_N))) begin
                    next_state = S15;
                end
                else if ((in_E != 'd1)) begin
                    next_state = S5;
                end
                else if ((in_C > &(in_G))) begin
                    next_state = S9;
                end
                else begin
                    next_state = S2;
                end
            end
            S5: begin
                if (((in_K < 'd1) || in_N)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S12;
                end
            end
            S6: begin
                next_state = S3;
            end
            S7: begin
                if ((in_P && in_L)) begin
                    next_state = S15;
                end
                else if ((|(in_O) ^ (in_K && in_J))) begin
                    next_state = S3;
                end
                else if ((in_G ^ (in_C != 'd1))) begin
                    next_state = S12;
                end
                else begin
                    next_state = S1;
                end
            end
            S8: begin
                if ((&(in_M) == 'd0)) begin
                    next_state = S4;
                end
                else if (((in_C != in_D) && in_L)) begin
                    next_state = S15;
                end
                else if ((~|(in_C) && in_K)) begin
                    next_state = S9;
                end
                else if ((in_H && in_J)) begin
                    next_state = S14;
                end
                else if (~|(in_I)) begin
                    next_state = S10;
                end
                else begin
                    next_state = S7;
                end
            end
            S9: begin
                if (~&(in_O)) begin
                    next_state = S5;
                end
                else if ((in_J && in_I)) begin
                    next_state = S13;
                end
                else if (((in_L != 'd1) && (in_F ^ in_M))) begin
                    next_state = S14;
                end
                else if ((in_A ^ in_M)) begin
                    next_state = S3;
                end
                else begin
                    next_state = S11;
                end
            end
            S10: begin
                next_state = S7;
            end
            S11: begin
                if (((in_O && in_D) > 'd0)) begin
                    next_state = S7;
                end
                else if ((in_L || in_E)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S9;
                end
            end
            S12: begin
                if (((in_G && in_I) == 'd0)) begin
                    next_state = S4;
                end
                else if (&(in_F)) begin
                    next_state = S7;
                end
                else if (((in_H != in_O) || in_L)) begin
                    next_state = S0;
                end
                else if ((in_B < 'd1)) begin
                    next_state = S1;
                end
                else if (~&((in_E == 'd0))) begin
                    next_state = S2;
                end
                else if (^((in_N == 'd1))) begin
                    next_state = S8;
                end
                else begin
                    next_state = S6;
                end
            end
            S13: begin
                if ((in_H == 'd1)) begin
                    next_state = S0;
                end
                else if (!(~|(in_L))) begin
                    next_state = S9;
                end
                else if (((in_G && in_H) == 'd1)) begin
                    next_state = S12;
                end
                else begin
                    next_state = S4;
                end
            end
            S14: begin
                if ((in_F || in_D)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S5;
                end
            end
            S15: begin
                if ((in_A == 'd0)) begin
                    next_state = S2;
                end
                else if (~(in_J)) begin
                    next_state = S3;
                end
                else if ((in_I == 'd0)) begin
                    next_state = S11;
                end
                else begin
                    next_state = S13;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
fsm,ni_16_nn_16_ne_64_wd_32_opd_5_0,"
`define WIDTH 32
module fsm(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    output reg [FSM_WIDTH-1:0] fsm_out;
    reg [FSM_WIDTH-1:0] state, next_state;
    always_ff @(posedge clk or negedge reset_) begin
        if (!reset_) begin
            state <= S0;
        end else begin
            state <= next_state;
        end
    end
    always_comb begin
        case(state)
            S0: begin
                if ((in_G != 'd1)) begin
                    next_state = S5;
                end
                else if ((in_D == 'd0)) begin
                    next_state = S10;
                end
                else if (((in_H > in_N) && (in_P ^ in_L))) begin
                    next_state = S12;
                end
                else if (((in_C != 'd1) || in_G)) begin
                    next_state = S6;
                end
                else if ((~^(in_E) || in_J)) begin
                    next_state = S1;
                end
                else if (((in_H == 'd0) && !(in_K))) begin
                    next_state = S11;
                end
                else begin
                    next_state = S7;
                end
            end
            S1: begin
                if (~&((in_I || in_P))) begin
                    next_state = S5;
                end
                else if ((in_C ^ in_O)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S12;
                end
            end
            S2: begin
                if ((in_I >= 'd1)) begin
                    next_state = S11;
                end
                else if ((in_E ^ in_N)) begin
                    next_state = S3;
                end
                else if ((in_L || (in_H || in_J))) begin
                    next_state = S1;
                end
                else if ((in_P ^ in_D)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S4;
                end
            end
            S3: begin
                if (((in_A <= 'd0) == 'd0)) begin
                    next_state = S8;
                end
                else if (((in_I < 'd0) == 'd0)) begin
                    next_state = S13;
                end
                else begin
                    next_state = S6;
                end
            end
            S4: begin
                if (((in_O || in_E) != ~|(in_C))) begin
                    next_state = S12;
                end
                else if ((in_E && (in_N && in_I))) begin
                    next_state = S15;
                end
                else if (((in_E ^ in_A) || (in_D ^ in_B))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S11;
                end
            end
            S5: begin
                if (((in_H || in_K) <= in_I)) begin
                    next_state = S1;
                end
                else if (((in_A != in_D) ^ in_B)) begin
                    next_state = S7;
                end
                else if ((in_I && (in_G || in_M))) begin
                    next_state = S6;
                end
                else begin
                    next_state = S3;
                end
            end
            S6: begin
                if ((in_L ^ in_N)) begin
                    next_state = S2;
                end
                else if ((in_J || in_O)) begin
                    next_state = S9;
                end
                else begin
                    next_state = S14;
                end
            end
            S7: begin
                if (^(in_B)) begin
                    next_state = S4;
                end
                else begin
                    next_state = S9;
                end
            end
            S8: begin
                if ((in_O != 'd0)) begin
                    next_state = S5;
                end
                else if ((in_P && in_I)) begin
                    next_state = S6;
                end
                else begin
                    next_state = S7;
                end
            end
            S9: begin
                if ((in_N || ^(in_P))) begin
                    next_state = S7;
                end
                else if (((in_P && in_B) == 'd1)) begin
                    next_state = S14;
                end
                else begin
                    next_state = S13;
                end
            end
            S10: begin
                if ((in_G ^ (in_F && in_K))) begin
                    next_state = S3;
                end
                else begin
                    next_state = S7;
                end
            end
            S11: begin
                if ((in_C != 'd0)) begin
                    next_state = S6;
                end
                else if (((in_P < 'd0) >= (in_C || in_K))) begin
                    next_state = S14;
                end
                else if ((^(in_H) <= 'd1)) begin
                    next_state = S8;
                end
                else begin
                    next_state = S0;
                end
            end
            S12: begin
                if ((in_N ^ in_F)) begin
                    next_state = S2;
                end
                else begin
                    next_state = S8;
                end
            end
            S13: begin
                if (|(in_J)) begin
                    next_state = S0;
                end
                else if ((in_K || (in_P && in_I))) begin
                    next_state = S5;
                end
                else if (~|((in_I != in_A))) begin
                    next_state = S7;
                end
                else begin
                    next_state = S8;
                end
            end
            S14: begin
                if (((in_D && in_I) && (in_A && in_F))) begin
                    next_state = S7;
                end
                else if ((in_D > &(in_J))) begin
                    next_state = S6;
                end
                else if (((in_E < 'd1) == (in_G <= 'd1))) begin
                    next_state = S12;
                end
                else if ((in_O || in_N)) begin
                    next_state = S2;
                end
                else if ((in_P ^ in_J)) begin
                    next_state = S15;
                end
                else begin
                    next_state = S8;
                end
            end
            S15: begin
                if ((in_C ^ in_J)) begin
                    next_state = S9;
                end
                else if (|((in_N != in_J))) begin
                    next_state = S14;
                end
                else if ((in_L || !(in_A))) begin
                    next_state = S8;
                end
                else if (((in_C != 'd1) && (in_B || in_L))) begin
                    next_state = S13;
                end
                else begin
                    next_state = S3;
                end
            end
        endcase
    end
endmodule",,"
`define WIDTH 32
module fsm_tb(
    clk,
    reset_,
    in_A,
    in_B,
    in_C,
    in_D,
    in_E,
    in_F,
    in_G,
    in_H,
    in_I,
    in_J,
    in_K,
    in_L,
    in_M,
    in_N,
    in_O,
    in_P,
    fsm_out
);
    parameter WIDTH = `WIDTH;
    parameter FSM_WIDTH = 4;

    parameter S0 = 4'b0000;
    parameter S1 = 4'b0001;
    parameter S2 = 4'b0010;
    parameter S3 = 4'b0011;
    parameter S4 = 4'b0100;
    parameter S5 = 4'b0101;
    parameter S6 = 4'b0110;
    parameter S7 = 4'b0111;
    parameter S8 = 4'b1000;
    parameter S9 = 4'b1001;
    parameter S10 = 4'b1010;
    parameter S11 = 4'b1011;
    parameter S12 = 4'b1100;
    parameter S13 = 4'b1101;
    parameter S14 = 4'b1110;
    parameter S15 = 4'b1111;

    input clk;
    input reset_;
    input [WIDTH-1:0] in_A;
    input [WIDTH-1:0] in_B;
    input [WIDTH-1:0] in_C;
    input [WIDTH-1:0] in_D;
    input [WIDTH-1:0] in_E;
    input [WIDTH-1:0] in_F;
    input [WIDTH-1:0] in_G;
    input [WIDTH-1:0] in_H;
    input [WIDTH-1:0] in_I;
    input [WIDTH-1:0] in_J;
    input [WIDTH-1:0] in_K;
    input [WIDTH-1:0] in_L;
    input [WIDTH-1:0] in_M;
    input [WIDTH-1:0] in_N;
    input [WIDTH-1:0] in_O;
    input [WIDTH-1:0] in_P;
    input reg [FSM_WIDTH-1:0] fsm_out;
    wire tb_reset;
    assign tb_reset = (reset_ == 1'b0);

endmodule
bind fsm fsm_tb #(
    .WIDTH(WIDTH)
) fsm_tb_inst (.*);
    "
