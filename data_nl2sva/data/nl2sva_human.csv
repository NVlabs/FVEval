design_name,task_id,prompt,ref_solution,testbench
counter,counter_0,"that the counter does not overflow. Use the signals 'count', 'count_d1', 'jump_vld_d1', and 'tb_reset_1_cycle_pulse_shadow'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    ((count_d1 === max) && !jump_vld_d1 && ((count <= min) || (count > max)) && !tb_reset_1_cycle_pulse_shadow) !== 1'b1
);","module counter_tb (
clk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value
);

    parameter width = 1;
    parameter min = 0;
    parameter [width:0] max = ((1<<width)-1);

input clk;
input reset_;
input [width-1:0] count;
input             incr_vld;
input [width-1:0] incr_value;
input             decr_vld;
input [width-1:0] decr_value;
input             jump_vld;
input [width-1:0] jump_value;


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;
wire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;
wire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};
wire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};


reg [width-1:0] eff_incr_d1;
reg [width-1:0] eff_decr_d1;
reg [width-1:0] net_incr_d1;
reg [width-1:0] net_decr_d1;

reg [width-1:0] count_d1;
reg             incr_vld_d1;
reg [width-1:0] incr_value_d1;
reg             decr_vld_d1;
reg [width-1:0] decr_value_d1;
reg             jump_vld_d1;
reg [width-1:0] jump_value_d1;

reg [width:0]     count_d1_next;
reg [width:0]     count_d1_next_p;
reg [width:0]     count_d1_next_m;

reg tb_reset_d1;
reg tb_reset_d2;
reg tb_reset_1_cycle_pulse_shadow;

always @(posedge clk) begin
    if (!reset_) begin 
        incr_vld_d1 <= 1'b0;
        decr_vld_d1 <= 1'b0;
        jump_vld_d1 <= 1'b0;
        eff_incr_d1 <= {width{1'b0}};
        eff_decr_d1 <= {width{1'b0}};
        net_incr_d1 <= {width{1'b0}};
        net_decr_d1 <= {width{1'b0}};
    end else begin
        eff_incr_d1 <= eff_incr;
        eff_decr_d1 <= eff_decr;
        net_incr_d1 <= net_incr;
        net_decr_d1 <= net_decr;
        incr_vld_d1 <= incr_vld;
        decr_vld_d1 <= decr_vld;
        jump_vld_d1 <= jump_vld;         
    end
end

always @(posedge clk) begin
        count_d1 <= count;
        incr_value_d1 <= incr_value;
        decr_value_d1 <= decr_value;
        jump_value_d1 <= jump_value;
        tb_reset_d1 <= tb_reset;          
        tb_reset_d2 <= tb_reset_d1;         
end
always @(posedge clk) begin
    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;
    count_d1_next_m <= count_d1 - net_decr_d1;
    count_d1_next_p <= count_d1 + net_incr_d1;
    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;
end

endmodule"
counter,counter_1,"that the counter does not underflow. Use the signals 'count', 'count_d1', 'jump_vld_d1', and 'tb_reset_1_cycle_pulse_shadow'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    ((count_d1 === min) && !jump_vld_d1 && ((count < min) || (count >= max)) && !tb_reset_1_cycle_pulse_shadow) !== 1'b1
);","module counter_tb (
clk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value
);

    parameter width = 1;
    parameter min = 0;
    parameter [width:0] max = ((1<<width)-1);

input clk;
input reset_;
input [width-1:0] count;
input             incr_vld;
input [width-1:0] incr_value;
input             decr_vld;
input [width-1:0] decr_value;
input             jump_vld;
input [width-1:0] jump_value;


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;
wire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;
wire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};
wire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};


reg [width-1:0] eff_incr_d1;
reg [width-1:0] eff_decr_d1;
reg [width-1:0] net_incr_d1;
reg [width-1:0] net_decr_d1;

reg [width-1:0] count_d1;
reg             incr_vld_d1;
reg [width-1:0] incr_value_d1;
reg             decr_vld_d1;
reg [width-1:0] decr_value_d1;
reg             jump_vld_d1;
reg [width-1:0] jump_value_d1;

reg [width:0]     count_d1_next;
reg [width:0]     count_d1_next_p;
reg [width:0]     count_d1_next_m;

reg tb_reset_d1;
reg tb_reset_d2;
reg tb_reset_1_cycle_pulse_shadow;

always @(posedge clk) begin
    if (!reset_) begin 
        incr_vld_d1 <= 1'b0;
        decr_vld_d1 <= 1'b0;
        jump_vld_d1 <= 1'b0;
        eff_incr_d1 <= {width{1'b0}};
        eff_decr_d1 <= {width{1'b0}};
        net_incr_d1 <= {width{1'b0}};
        net_decr_d1 <= {width{1'b0}};
    end else begin
        eff_incr_d1 <= eff_incr;
        eff_decr_d1 <= eff_decr;
        net_incr_d1 <= net_incr;
        net_decr_d1 <= net_decr;
        incr_vld_d1 <= incr_vld;
        decr_vld_d1 <= decr_vld;
        jump_vld_d1 <= jump_vld;         
    end
end

always @(posedge clk) begin
        count_d1 <= count;
        incr_value_d1 <= incr_value;
        decr_value_d1 <= decr_value;
        jump_value_d1 <= jump_value;
        tb_reset_d1 <= tb_reset;          
        tb_reset_d2 <= tb_reset_d1;         
end
always @(posedge clk) begin
    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;
    count_d1_next_m <= count_d1 - net_decr_d1;
    count_d1_next_p <= count_d1 + net_incr_d1;
    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;
end

endmodule"
counter,counter_2,that the counter count value is within legal range. Use the signal 'count'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    ((count < min) || (count > max)) !== 1'b1
);","module counter_tb (
clk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value
);

    parameter width = 1;
    parameter min = 0;
    parameter [width:0] max = ((1<<width)-1);

input clk;
input reset_;
input [width-1:0] count;
input             incr_vld;
input [width-1:0] incr_value;
input             decr_vld;
input [width-1:0] decr_value;
input             jump_vld;
input [width-1:0] jump_value;


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;
wire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;
wire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};
wire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};


reg [width-1:0] eff_incr_d1;
reg [width-1:0] eff_decr_d1;
reg [width-1:0] net_incr_d1;
reg [width-1:0] net_decr_d1;

reg [width-1:0] count_d1;
reg             incr_vld_d1;
reg [width-1:0] incr_value_d1;
reg             decr_vld_d1;
reg [width-1:0] decr_value_d1;
reg             jump_vld_d1;
reg [width-1:0] jump_value_d1;

reg [width:0]     count_d1_next;
reg [width:0]     count_d1_next_p;
reg [width:0]     count_d1_next_m;

reg tb_reset_d1;
reg tb_reset_d2;
reg tb_reset_1_cycle_pulse_shadow;

always @(posedge clk) begin
    if (!reset_) begin 
        incr_vld_d1 <= 1'b0;
        decr_vld_d1 <= 1'b0;
        jump_vld_d1 <= 1'b0;
        eff_incr_d1 <= {width{1'b0}};
        eff_decr_d1 <= {width{1'b0}};
        net_incr_d1 <= {width{1'b0}};
        net_decr_d1 <= {width{1'b0}};
    end else begin
        eff_incr_d1 <= eff_incr;
        eff_decr_d1 <= eff_decr;
        net_incr_d1 <= net_incr;
        net_decr_d1 <= net_decr;
        incr_vld_d1 <= incr_vld;
        decr_vld_d1 <= decr_vld;
        jump_vld_d1 <= jump_vld;         
    end
end

always @(posedge clk) begin
        count_d1 <= count;
        incr_value_d1 <= incr_value;
        decr_value_d1 <= decr_value;
        jump_value_d1 <= jump_value;
        tb_reset_d1 <= tb_reset;          
        tb_reset_d2 <= tb_reset_d1;         
end
always @(posedge clk) begin
    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;
    count_d1_next_m <= count_d1 - net_decr_d1;
    count_d1_next_p <= count_d1 + net_incr_d1;
    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;
end

endmodule"
counter,counter_3,"that for the jump case, counter is properly assigned with the jump value. Use the signals 'count' and 'jump_vld_d1'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (jump_vld_d1 && (count !== jump_value_d1)) !== 1'b1
);","module counter_tb (
clk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value
);

    parameter width = 1;
    parameter min = 0;
    parameter [width:0] max = ((1<<width)-1);

input clk;
input reset_;
input [width-1:0] count;
input             incr_vld;
input [width-1:0] incr_value;
input             decr_vld;
input [width-1:0] decr_value;
input             jump_vld;
input [width-1:0] jump_value;


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;
wire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;
wire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};
wire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};


reg [width-1:0] eff_incr_d1;
reg [width-1:0] eff_decr_d1;
reg [width-1:0] net_incr_d1;
reg [width-1:0] net_decr_d1;

reg [width-1:0] count_d1;
reg             incr_vld_d1;
reg [width-1:0] incr_value_d1;
reg             decr_vld_d1;
reg [width-1:0] decr_value_d1;
reg             jump_vld_d1;
reg [width-1:0] jump_value_d1;

reg [width:0]     count_d1_next;
reg [width:0]     count_d1_next_p;
reg [width:0]     count_d1_next_m;

reg tb_reset_d1;
reg tb_reset_d2;
reg tb_reset_1_cycle_pulse_shadow;

always @(posedge clk) begin
    if (!reset_) begin 
        incr_vld_d1 <= 1'b0;
        decr_vld_d1 <= 1'b0;
        jump_vld_d1 <= 1'b0;
        eff_incr_d1 <= {width{1'b0}};
        eff_decr_d1 <= {width{1'b0}};
        net_incr_d1 <= {width{1'b0}};
        net_decr_d1 <= {width{1'b0}};
    end else begin
        eff_incr_d1 <= eff_incr;
        eff_decr_d1 <= eff_decr;
        net_incr_d1 <= net_incr;
        net_decr_d1 <= net_decr;
        incr_vld_d1 <= incr_vld;
        decr_vld_d1 <= decr_vld;
        jump_vld_d1 <= jump_vld;         
    end
end

always @(posedge clk) begin
        count_d1 <= count;
        incr_value_d1 <= incr_value;
        decr_value_d1 <= decr_value;
        jump_value_d1 <= jump_value;
        tb_reset_d1 <= tb_reset;          
        tb_reset_d2 <= tb_reset_d1;         
end
always @(posedge clk) begin
    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;
    count_d1_next_m <= count_d1 - net_decr_d1;
    count_d1_next_p <= count_d1 + net_incr_d1;
    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;
end

endmodule"
counter,counter_4,"that if there is no increment, decrement or jump, the counter should retain its value. Use the signals 'count', 'count_d1', 'jump_vld_d1', 'incr_vld_d1', 'decr_vld_d1', and 'tb_reset_1_cycle_pulse_shadow'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (!incr_vld_d1 && !decr_vld_d1 && !jump_vld_d1 && (count !== count_d1) && !tb_reset_1_cycle_pulse_shadow) !== 1'b1
);","module counter_tb (
clk, reset_, count, incr_vld, incr_value, decr_vld, decr_value, jump_vld, jump_value
);

    parameter width = 1;
    parameter min = 0;
    parameter [width:0] max = ((1<<width)-1);

input clk;
input reset_;
input [width-1:0] count;
input             incr_vld;
input [width-1:0] incr_value;
input             decr_vld;
input [width-1:0] decr_value;
input             jump_vld;
input [width-1:0] jump_value;


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [width-1:0] eff_incr = {width{incr_vld}} & incr_value;
wire [width-1:0] eff_decr = {width{decr_vld}} & decr_value;
wire [width-1:0] net_incr = (eff_incr>eff_decr) ? (eff_incr-eff_decr) : {width{1'b0}};
wire [width-1:0] net_decr = (eff_decr>eff_incr) ? (eff_decr-eff_incr) : {width{1'b0}};


reg [width-1:0] eff_incr_d1;
reg [width-1:0] eff_decr_d1;
reg [width-1:0] net_incr_d1;
reg [width-1:0] net_decr_d1;

reg [width-1:0] count_d1;
reg             incr_vld_d1;
reg [width-1:0] incr_value_d1;
reg             decr_vld_d1;
reg [width-1:0] decr_value_d1;
reg             jump_vld_d1;
reg [width-1:0] jump_value_d1;

reg [width:0]     count_d1_next;
reg [width:0]     count_d1_next_p;
reg [width:0]     count_d1_next_m;

reg tb_reset_d1;
reg tb_reset_d2;
reg tb_reset_1_cycle_pulse_shadow;

always @(posedge clk) begin
    if (!reset_) begin 
        incr_vld_d1 <= 1'b0;
        decr_vld_d1 <= 1'b0;
        jump_vld_d1 <= 1'b0;
        eff_incr_d1 <= {width{1'b0}};
        eff_decr_d1 <= {width{1'b0}};
        net_incr_d1 <= {width{1'b0}};
        net_decr_d1 <= {width{1'b0}};
    end else begin
        eff_incr_d1 <= eff_incr;
        eff_decr_d1 <= eff_decr;
        net_incr_d1 <= net_incr;
        net_decr_d1 <= net_decr;
        incr_vld_d1 <= incr_vld;
        decr_vld_d1 <= decr_vld;
        jump_vld_d1 <= jump_vld;         
    end
end

always @(posedge clk) begin
        count_d1 <= count;
        incr_value_d1 <= incr_value;
        decr_value_d1 <= decr_value;
        jump_value_d1 <= jump_value;
        tb_reset_d1 <= tb_reset;          
        tb_reset_d2 <= tb_reset_d1;         
end
always @(posedge clk) begin
    count_d1_next <= count_d1 + net_incr_d1 - net_decr_d1;
    count_d1_next_m <= count_d1 - net_decr_d1;
    count_d1_next_p <= count_d1 + net_incr_d1;
    tb_reset_1_cycle_pulse_shadow <=!tb_reset_d2 && tb_reset_d1 && !tb_reset;
end

endmodule"
arbiter_reverse_priority,arbiter_0,that the arbiter grant signal is 0-1-hot. Use the signal 'tb_gnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !($onehot0(tb_gnt)) !== 1'b1
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_reverse_priority,arbiter_3,"that if there is a req, there will be a grant except when busy. Use the signals 'tb_req', 'busy', and 'tb_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (!busy && |tb_req && (tb_gnt == 'd0)) !== 1'b1
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_reverse_priority,arbiter_4,that each grant must be to a requesting client only. Use the signals 'tb_req' and 'tb_gnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && ((tb_gnt & tb_req) == 'd0)) !== 1'b1
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_reverse_priority,arbiter_5,"that no grants are made when the arbiter downstream is busy. Use the signals 'tb_gnt', 'hold', 'busy', and 'last_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && busy) !== 1'b1
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_reverse_priority,arbiter_6,"that the arbiter holds onto grants when there is hold. Use the signals 'tb_gnt', 'hold', and 'tb_req'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    (hold && !busy && (tb_gnt != last_gnt)) !== 1'b1 
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_reverse_priority,arbiter_7,"that the given arbiter follows the priority policy: always grant the highest priority client that is currently requesting. Use the signals 'tb_gnt', 'hold', and 'tb_req'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && !hold && |((tb_gnt - 'd1) & tb_req)) !== 1'b1
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_reverse_priority,arbiter_9,"that the arbiter is never on hold or busy or on continued grant at the same time. Use the signals 'busy', 'hold', and 'cont_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !$onehot0({hold,busy,cont_gnt}) !== 1'b1
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_reverse_priority,arbiter_10,that each grant id is proper. Use the signals 'tb_gnt' and 'gnt_id'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && (tb_gnt[gnt_id] != 1'b1)) !== 1'b1
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_reverse_priority,arbiter_11,"that each grant id is proper, for the case where there no grants yet.Use the signals 'tb_gnt' and 'gnt_id'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    ((tb_gnt == 0) && (gnt_id != 0)) !== 1'b1
);","module arbiter_reverse_priority_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;


genvar a;
for(a=0;a<NUM_OF_CLIENTS;a++) begin 
    assign tb_req[a] = req[NUM_OF_CLIENTS-1-a];
    assign tb_gnt[a] = gnt[NUM_OF_CLIENTS-1-a];
    assign tb_req_for_starvation[a] = req[NUM_OF_CLIENTS-1-a];
end

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end


genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
fsm_transition,fsm_transition_1,that each of the FSM states provided as the input sequence should end in the final end state. Use the signal 'match_tracker'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !(|(match_tracker[0])) !== 1'b1     
);","module fsm_transition_tb (
clk, 
reset_, 
fsm_state,
fsm_sequence
);
    parameter fsm_width = 2; //actual width of the states in the RTL
    parameter num_of_states=2; //number of states provided in the fsm_sequence
    parameter num_of_times_initial_state_repeats=1; //Number of times the initial state of the ""fsm_sequence"" is repeated in the ""fsm_sequence""  

input clk;
input reset_;
input [fsm_width-1:0]fsm_state;
input [fsm_width*num_of_states-1:0]fsm_sequence;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

//Proper sequencing of the states
wire [fsm_width-1:0] tb_fsm_sequence[num_of_states-1:0]; 

//match the current ""fsm_state"" with the states provided in the ""fsm_sequence""
wire [num_of_states-1:0]match_tracker[num_of_times_initial_state_repeats-1:0]; 
reg [num_of_states-1:0]match_tracker_d1[num_of_times_initial_state_repeats-1:0]; 

//match the current ""fsm_state"" with the states provided in the ""fsm_sequence"" when checking for individual states
wire [num_of_states-1:0]ind_state_match_tracker[num_of_times_initial_state_repeats-1:0]; 
reg [num_of_states-1:0]ind_state_match_tracker_d1[num_of_times_initial_state_repeats-1:0]; 

//Track all the states of the ""fsm_sequence""
reg [num_of_states-1:0]state_tracker[num_of_times_initial_state_repeats-1:0]; 

reg [fsm_width-1:0] fsm_state_d1;
reg tb_reset_d1;
wire [fsm_width-1:0] tb_random_state;
wire [$clog2(num_of_times_initial_state_repeats):0]tb_sequence_seen;


//storing the states of the fsm_sequence in the correct order
for (genvar i=num_of_states-1; i >=0; i--) begin : storing_of_fsm_states
    assign  tb_fsm_sequence[num_of_states-1-i] = fsm_sequence[(fsm_width*(i+1))-1 : fsm_width*i];
end

//Delayed versions of fsm_state and tb_reset
always @(posedge clk) begin
    if (!reset_) begin
        fsm_state_d1 <= 'd0;
        tb_reset_d1 <= 1;
    end else begin
        fsm_state_d1 <= fsm_state;
        tb_reset_d1 <= tb_reset;  
    end
end

for (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : matching_of_states_as_per_initial_state_repeat
    if (n==0) begin : matching_of_states_for_certain_cases
        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states
            if (i==0) begin : matching_of_states_for_first_state 
                assign ind_state_match_tracker[n][0] = (fsm_state == tb_fsm_sequence[0]);
            end else begin : matching_of_states_for_other_states 
                assign ind_state_match_tracker[n][i] = (fsm_state == tb_fsm_sequence[i]);
            end
        end 
    end else begin : matching_of_states_for_other_cases
        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states
            if (i==0) begin : matching_of_states_for_first_state 
            assign ind_state_match_tracker[n][0] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) 
                                            ? (!(|state_tracker[n]) && (|state_tracker[n-1]) && (fsm_state == tb_fsm_sequence[0])) 
                                            : ind_state_match_tracker[n][0] ;
            end else begin : matching_of_states_for_other_states
            assign ind_state_match_tracker[n][i] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) 
                                            ? (!state_tracker[n][i] && state_tracker[n][i-1] && (fsm_state == tb_fsm_sequence[i])) 
                                            : ind_state_match_tracker[n][i] ;
            end
        end 
    end
end

reg [$clog2(num_of_times_initial_state_repeats):0] j;

always @(posedge clk) begin
    if (!reset_) begin
        for (j=0; j< num_of_times_initial_state_repeats; j++) begin
            state_tracker[j] <= 'd0;
            match_tracker_d1[j] <= 'd0;
            ind_state_match_tracker_d1[j] <= 'd0;
        end
    end else begin
        for (j=0; j< num_of_times_initial_state_repeats; j++) begin
            match_tracker_d1[j] <= match_tracker[j];
            ind_state_match_tracker_d1[j] <= ind_state_match_tracker[j];
            if (j==0) 
            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || 
                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && 
                                    (|match_tracker[j] != 'd0)) 
                                        ? state_tracker[j]|match_tracker[j] 
                                        : ((((|match_tracker[j]) == 0) && (fsm_state == tb_fsm_sequence[0])) 
                                            ? 'd1 
                                            : 'd0
                                        );
            else 
            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || 
                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && 
                                    (|match_tracker[j] != 'd0)) 
                                    ? state_tracker[j]|match_tracker[j] 
                                    : 'd0;
        end
    end
end


endmodule"
fifo_1r1w,fifo_0,"that the FIFO does not underflow, assuming no bypass. Use the signals 'rd_pop' and 'fifo_empty'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    (fifo_empty && rd_pop) !== 1'b1
);","module fifo_1r1w_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

// ---- shift register code start ----
always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

// ---- read pointer/fifo empty code start ----
always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
// ---- fifo full and dout code start ----
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];

endmodule"
fifo_1r1w,fifo_1,"that the FIFO does not overflow, assuming no bypass. Use the signals 'wr_push' and 'fifo_full'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    (fifo_full && wr_push) !== 1'b1
);","module fifo_1r1w_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

// ---- shift register code start ----
always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

// ---- read pointer/fifo empty code start ----
always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
// ---- fifo full and dout code start ----
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];

endmodule"
fifo_1r1w,fifo_2,"that the fifo output and read data are consistent, assuming no bypass. Use the signals 'rd_pop', 'rd_data', and 'fifo_out_data'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
       (rd_pop && (fifo_out_data != rd_data)) !== 1'b1
);","module fifo_1r1w_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

// ---- shift register code start ----
always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

// ---- read pointer/fifo empty code start ----
always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
// ---- fifo full and dout code start ----
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];

endmodule"
fifo_1r1w,fifo_3,"that when response is pending, data is eventually popped from the FIFO. Use the signals 'rd_pop' and 'fifo_empty'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
       !fifo_empty |-> strong(##[0:$] rd_pop)
);","module fifo_1r1w_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

// ---- shift register code start ----
always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

// ---- read pointer/fifo empty code start ----
always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
// ---- fifo full and dout code start ----
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];

endmodule"
fifo_1r1w,fifo_4,"that when there is a write push to the FIFO, data is eventually popped. Use the signals 'rd_pop' and 'wr_push'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
       wr_push |-> strong(##[0:$] rd_pop)
);","module fifo_1r1w_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

// ---- shift register code start ----
always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

// ---- read pointer/fifo empty code start ----
always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
// ---- fifo full and dout code start ----
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];

endmodule"
multi_fifo,multi_fifo_1,"for forward progress: whenever there is a push, an output data pop eventually happens. Use the signals 'tb_push_cnt' and 'tb_pop_cnt'.","asrt: assert property(@(posedge clk) disable iff (tb_reset)
    (|tb_push_cnt) |-> strong(##[0:$] |tb_pop_cnt)
);","module multi_fifo_tb (
clk,
reset_,
wr_vld,
wr_data,
wr_ready,
rd_vld,
rd_data,
rd_ready
);

    parameter   max_fifo_entries = 4;
    parameter   wr_port = 1;
    parameter   rd_port = 1;
    parameter   data_width = 1;

    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );
    localparam wr_port_log2 = $clog2(wr_port +1 );
    localparam rand_bit_selector = $clog2(data_width);


input clk;
input reset_;
input [(wr_port)-1:0] wr_vld;
input [(data_width * wr_port)-1:0] wr_data;
input [(wr_port)-1:0] wr_ready;
input [(rd_port)-1:0] rd_vld;
input [(data_width * rd_port)-1:0] rd_data;
input [(rd_port)-1:0] rd_ready;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

reg [(fifo_entry_cntr-1):0] tb_wr_ptr;
reg [(fifo_entry_cntr-1):0] tb_rd_ptr;

reg [(wr_port - 1):0] tb_wr_data_for_fv;
reg [(rd_port - 1):0] tb_rd_data_for_fv;

reg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];
reg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];



wire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;
wire tb_fifo_should_not_underflow_err;
wire tb_filled_cnt_less_or_equal_max_entries_err;
wire tb_fifo_should_not_overflow_err;
wire [wr_port-1:0] tb_wr_vld_is_contiguous_err;
wire [wr_port-1:0] tb_wr_ready_is_contiguous_err;
wire [rd_port-1:0] tb_rd_vld_is_contiguous_err;
wire [rd_port-1:0] tb_rd_ready_is_contiguous_err;


wire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; 
generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv
    always_comb
    begin
        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv
    always_comb
    begin
        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim
    always_comb
    begin
        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim
    always_comb
    begin
        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

wire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);
wire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);
wire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;

wire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;

always @(posedge clk)
begin
    if (!reset_) begin
        tb_wr_ptr <= 0;
        tb_rd_ptr <= 0;
    end else begin
        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write
        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr
        end else begin
        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read
        end
    end
end

reg registered_data;
reg [(fifo_entry_cntr-1):0] registered_ptr;
reg [(wr_port)-1:0] registered_data_next;
reg [(wr_port)-1:0] registered_data_update;

reg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];
reg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;

always @(posedge clk)
begin
    if (!reset_) begin
        registered_ptr <= 'x;                 // registered_ptr is random during reset
    end else begin
        registered_ptr <= registered_ptr;     // else it retiains its value
    end
end

// when wr_ptr == registered_ptr, register data
generate
for (genvar i=0; i<wr_port; i++) begin:register_write_data
    always_comb
    begin
        registered_data_next[i] = 0;
        registered_data_update[i] = 0;
        tb_random_bit_selector_next[i] = 0;
        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin
            registered_data_update[i] = 1;
            registered_data_next[i] = tb_wr_data_for_fv[i];
            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];
        end
    end
end
endgenerate

// register selector
reg [wr_port_log2-1:0] wr_index;
reg [rand_bit_selector-1:0] tb_random_bit_next;
always_comb begin
    tb_random_bit_next = 0;
    for (wr_index=0; wr_index < wr_port; wr_index++) begin
        if (registered_data_update[wr_index]) begin
            tb_random_bit_next = tb_random_bit_selector_next[wr_index];
        end
    end
end

// register data
always @ (posedge clk)
begin
    if (|registered_data_update) begin
        registered_data <= |registered_data_next;
        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;
    end
end

reg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];
reg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];
reg [(fifo_entry_cntr-1):0] tb_shift;

reg [(fifo_entry_cntr-1):0] n;
always @ (posedge clk)
begin
if (tb_shift == 0) 
    for (n=0; n < max_fifo_entries; n++) begin
        fifo_data_tracker[n] <= fifo_data_tracker_next[n];
    end
else if (tb_shift > (max_fifo_entries+wr_port-1)) begin
  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;
end else begin
    for (n=0; n<max_fifo_entries; n++) begin 
        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin
          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];
        end
    end  
end
end     

generate
for (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next
    always_comb
    begin
        if (i<tb_fifo_filled_cnt) begin
        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data
        end
        else if (i <tb_fifo_filled_cnt + wr_port) begin
        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data
        end
        // else dont care
    end
end
endgenerate

always_comb
begin
    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;
    end else begin
        tb_shift = tb_pop_cnt;
    end
end

endmodule"
multi_fifo,multi_fifo_2,"for forward progress: whenever the FIFO becomes full, an output data pop eventually happens. Use the signals 'tb_fifo_filled_cnt' and 'tb_pop_cnt'.","asrt: assert property(@(posedge clk) disable iff (tb_reset)
    (|tb_fifo_filled_cnt) |-> strong(##[0:$] |tb_pop_cnt)
);","module multi_fifo_tb (
clk,
reset_,
wr_vld,
wr_data,
wr_ready,
rd_vld,
rd_data,
rd_ready
);

    parameter   max_fifo_entries = 4;
    parameter   wr_port = 1;
    parameter   rd_port = 1;
    parameter   data_width = 1;

    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );
    localparam wr_port_log2 = $clog2(wr_port +1 );
    localparam rand_bit_selector = $clog2(data_width);


input clk;
input reset_;
input [(wr_port)-1:0] wr_vld;
input [(data_width * wr_port)-1:0] wr_data;
input [(wr_port)-1:0] wr_ready;
input [(rd_port)-1:0] rd_vld;
input [(data_width * rd_port)-1:0] rd_data;
input [(rd_port)-1:0] rd_ready;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

reg [(fifo_entry_cntr-1):0] tb_wr_ptr;
reg [(fifo_entry_cntr-1):0] tb_rd_ptr;

reg [(wr_port - 1):0] tb_wr_data_for_fv;
reg [(rd_port - 1):0] tb_rd_data_for_fv;

reg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];
reg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];



wire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;
wire tb_fifo_should_not_underflow_err;
wire tb_filled_cnt_less_or_equal_max_entries_err;
wire tb_fifo_should_not_overflow_err;
wire [wr_port-1:0] tb_wr_vld_is_contiguous_err;
wire [wr_port-1:0] tb_wr_ready_is_contiguous_err;
wire [rd_port-1:0] tb_rd_vld_is_contiguous_err;
wire [rd_port-1:0] tb_rd_ready_is_contiguous_err;


wire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; 
generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv
    always_comb
    begin
        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv
    always_comb
    begin
        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim
    always_comb
    begin
        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim
    always_comb
    begin
        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

wire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);
wire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);
wire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;

wire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;

always @(posedge clk)
begin
    if (!reset_) begin
        tb_wr_ptr <= 0;
        tb_rd_ptr <= 0;
    end else begin
        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write
        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr
        end else begin
        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read
        end
    end
end

reg registered_data;
reg [(fifo_entry_cntr-1):0] registered_ptr;
reg [(wr_port)-1:0] registered_data_next;
reg [(wr_port)-1:0] registered_data_update;

reg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];
reg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;

always @(posedge clk)
begin
    if (!reset_) begin
        registered_ptr <= 'x;                 // registered_ptr is random during reset
    end else begin
        registered_ptr <= registered_ptr;     // else it retiains its value
    end
end

// when wr_ptr == registered_ptr, register data
generate
for (genvar i=0; i<wr_port; i++) begin:register_write_data
    always_comb
    begin
        registered_data_next[i] = 0;
        registered_data_update[i] = 0;
        tb_random_bit_selector_next[i] = 0;
        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin
            registered_data_update[i] = 1;
            registered_data_next[i] = tb_wr_data_for_fv[i];
            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];
        end
    end
end
endgenerate

// register selector
reg [wr_port_log2-1:0] wr_index;
reg [rand_bit_selector-1:0] tb_random_bit_next;
always_comb begin
    tb_random_bit_next = 0;
    for (wr_index=0; wr_index < wr_port; wr_index++) begin
        if (registered_data_update[wr_index]) begin
            tb_random_bit_next = tb_random_bit_selector_next[wr_index];
        end
    end
end

// register data
always @ (posedge clk)
begin
    if (|registered_data_update) begin
        registered_data <= |registered_data_next;
        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;
    end
end

reg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];
reg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];
reg [(fifo_entry_cntr-1):0] tb_shift;

reg [(fifo_entry_cntr-1):0] n;
always @ (posedge clk)
begin
if (tb_shift == 0) 
    for (n=0; n < max_fifo_entries; n++) begin
        fifo_data_tracker[n] <= fifo_data_tracker_next[n];
    end
else if (tb_shift > (max_fifo_entries+wr_port-1)) begin
  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;
end else begin
    for (n=0; n<max_fifo_entries; n++) begin 
        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin
          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];
        end
    end  
end
end     

generate
for (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next
    always_comb
    begin
        if (i<tb_fifo_filled_cnt) begin
        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data
        end
        else if (i <tb_fifo_filled_cnt + wr_port) begin
        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data
        end
        // else dont care
    end
end
endgenerate

always_comb
begin
    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;
    end else begin
        tb_shift = tb_pop_cnt;
    end
end

endmodule"
multi_fifo,multi_fifo_4,"that when the pop count is greater than current filled count, then FIFO goes through underflow. Use the signals 'tb_fifo_filled_cnt' and 'tb_pop_cnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (tb_pop_cnt > tb_fifo_filled_cnt) !== 1'b1
);","module multi_fifo_tb (
clk,
reset_,
wr_vld,
wr_data,
wr_ready,
rd_vld,
rd_data,
rd_ready
);

    parameter   max_fifo_entries = 4;
    parameter   wr_port = 1;
    parameter   rd_port = 1;
    parameter   data_width = 1;

    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );
    localparam wr_port_log2 = $clog2(wr_port +1 );
    localparam rand_bit_selector = $clog2(data_width);


input clk;
input reset_;
input [(wr_port)-1:0] wr_vld;
input [(data_width * wr_port)-1:0] wr_data;
input [(wr_port)-1:0] wr_ready;
input [(rd_port)-1:0] rd_vld;
input [(data_width * rd_port)-1:0] rd_data;
input [(rd_port)-1:0] rd_ready;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

reg [(fifo_entry_cntr-1):0] tb_wr_ptr;
reg [(fifo_entry_cntr-1):0] tb_rd_ptr;

reg [(wr_port - 1):0] tb_wr_data_for_fv;
reg [(rd_port - 1):0] tb_rd_data_for_fv;

reg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];
reg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];



wire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;
wire tb_fifo_should_not_underflow_err;
wire tb_filled_cnt_less_or_equal_max_entries_err;
wire tb_fifo_should_not_overflow_err;
wire [wr_port-1:0] tb_wr_vld_is_contiguous_err;
wire [wr_port-1:0] tb_wr_ready_is_contiguous_err;
wire [rd_port-1:0] tb_rd_vld_is_contiguous_err;
wire [rd_port-1:0] tb_rd_ready_is_contiguous_err;


wire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; 
generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv
    always_comb
    begin
        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv
    always_comb
    begin
        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim
    always_comb
    begin
        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim
    always_comb
    begin
        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

wire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);
wire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);
wire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;

wire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;

always @(posedge clk)
begin
    if (!reset_) begin
        tb_wr_ptr <= 0;
        tb_rd_ptr <= 0;
    end else begin
        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write
        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr
        end else begin
        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read
        end
    end
end

reg registered_data;
reg [(fifo_entry_cntr-1):0] registered_ptr;
reg [(wr_port)-1:0] registered_data_next;
reg [(wr_port)-1:0] registered_data_update;

reg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];
reg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;

always @(posedge clk)
begin
    if (!reset_) begin
        registered_ptr <= 'x;                 // registered_ptr is random during reset
    end else begin
        registered_ptr <= registered_ptr;     // else it retiains its value
    end
end

// when wr_ptr == registered_ptr, register data
generate
for (genvar i=0; i<wr_port; i++) begin:register_write_data
    always_comb
    begin
        registered_data_next[i] = 0;
        registered_data_update[i] = 0;
        tb_random_bit_selector_next[i] = 0;
        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin
            registered_data_update[i] = 1;
            registered_data_next[i] = tb_wr_data_for_fv[i];
            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];
        end
    end
end
endgenerate

// register selector
reg [wr_port_log2-1:0] wr_index;
reg [rand_bit_selector-1:0] tb_random_bit_next;
always_comb begin
    tb_random_bit_next = 0;
    for (wr_index=0; wr_index < wr_port; wr_index++) begin
        if (registered_data_update[wr_index]) begin
            tb_random_bit_next = tb_random_bit_selector_next[wr_index];
        end
    end
end

// register data
always @ (posedge clk)
begin
    if (|registered_data_update) begin
        registered_data <= |registered_data_next;
        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;
    end
end

reg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];
reg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];
reg [(fifo_entry_cntr-1):0] tb_shift;

reg [(fifo_entry_cntr-1):0] n;
always @ (posedge clk)
begin
if (tb_shift == 0) 
    for (n=0; n < max_fifo_entries; n++) begin
        fifo_data_tracker[n] <= fifo_data_tracker_next[n];
    end
else if (tb_shift > (max_fifo_entries+wr_port-1)) begin
  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;
end else begin
    for (n=0; n<max_fifo_entries; n++) begin 
        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin
          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];
        end
    end  
end
end     

generate
for (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next
    always_comb
    begin
        if (i<tb_fifo_filled_cnt) begin
        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data
        end
        else if (i <tb_fifo_filled_cnt + wr_port) begin
        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data
        end
        // else dont care
    end
end
endgenerate

always_comb
begin
    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;
    end else begin
        tb_shift = tb_pop_cnt;
    end
end

endmodule"
multi_fifo,multi_fifo_5,that the filled count is less than or equal to maximum allowed entires in the FIFO. Use the signal 'tb_fifo_filled_cnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (tb_fifo_filled_cnt > max_fifo_entries) !== 1'b1
);","module multi_fifo_tb (
clk,
reset_,
wr_vld,
wr_data,
wr_ready,
rd_vld,
rd_data,
rd_ready
);

    parameter   max_fifo_entries = 4;
    parameter   wr_port = 1;
    parameter   rd_port = 1;
    parameter   data_width = 1;

    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );
    localparam wr_port_log2 = $clog2(wr_port +1 );
    localparam rand_bit_selector = $clog2(data_width);


input clk;
input reset_;
input [(wr_port)-1:0] wr_vld;
input [(data_width * wr_port)-1:0] wr_data;
input [(wr_port)-1:0] wr_ready;
input [(rd_port)-1:0] rd_vld;
input [(data_width * rd_port)-1:0] rd_data;
input [(rd_port)-1:0] rd_ready;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

reg [(fifo_entry_cntr-1):0] tb_wr_ptr;
reg [(fifo_entry_cntr-1):0] tb_rd_ptr;

reg [(wr_port - 1):0] tb_wr_data_for_fv;
reg [(rd_port - 1):0] tb_rd_data_for_fv;

reg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];
reg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];



wire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;
wire tb_fifo_should_not_underflow_err;
wire tb_filled_cnt_less_or_equal_max_entries_err;
wire tb_fifo_should_not_overflow_err;
wire [wr_port-1:0] tb_wr_vld_is_contiguous_err;
wire [wr_port-1:0] tb_wr_ready_is_contiguous_err;
wire [rd_port-1:0] tb_rd_vld_is_contiguous_err;
wire [rd_port-1:0] tb_rd_ready_is_contiguous_err;


wire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; 
generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv
    always_comb
    begin
        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv
    always_comb
    begin
        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim
    always_comb
    begin
        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim
    always_comb
    begin
        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

wire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);
wire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);
wire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;

wire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;

always @(posedge clk)
begin
    if (!reset_) begin
        tb_wr_ptr <= 0;
        tb_rd_ptr <= 0;
    end else begin
        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write
        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr
        end else begin
        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read
        end
    end
end

reg registered_data;
reg [(fifo_entry_cntr-1):0] registered_ptr;
reg [(wr_port)-1:0] registered_data_next;
reg [(wr_port)-1:0] registered_data_update;

reg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];
reg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;

always @(posedge clk)
begin
    if (!reset_) begin
        registered_ptr <= 'x;                 // registered_ptr is random during reset
    end else begin
        registered_ptr <= registered_ptr;     // else it retiains its value
    end
end

// when wr_ptr == registered_ptr, register data
generate
for (genvar i=0; i<wr_port; i++) begin:register_write_data
    always_comb
    begin
        registered_data_next[i] = 0;
        registered_data_update[i] = 0;
        tb_random_bit_selector_next[i] = 0;
        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin
            registered_data_update[i] = 1;
            registered_data_next[i] = tb_wr_data_for_fv[i];
            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];
        end
    end
end
endgenerate

// register selector
reg [wr_port_log2-1:0] wr_index;
reg [rand_bit_selector-1:0] tb_random_bit_next;
always_comb begin
    tb_random_bit_next = 0;
    for (wr_index=0; wr_index < wr_port; wr_index++) begin
        if (registered_data_update[wr_index]) begin
            tb_random_bit_next = tb_random_bit_selector_next[wr_index];
        end
    end
end

// register data
always @ (posedge clk)
begin
    if (|registered_data_update) begin
        registered_data <= |registered_data_next;
        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;
    end
end

reg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];
reg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];
reg [(fifo_entry_cntr-1):0] tb_shift;

reg [(fifo_entry_cntr-1):0] n;
always @ (posedge clk)
begin
if (tb_shift == 0) 
    for (n=0; n < max_fifo_entries; n++) begin
        fifo_data_tracker[n] <= fifo_data_tracker_next[n];
    end
else if (tb_shift > (max_fifo_entries+wr_port-1)) begin
  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;
end else begin
    for (n=0; n<max_fifo_entries; n++) begin 
        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin
          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];
        end
    end  
end
end     

generate
for (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next
    always_comb
    begin
        if (i<tb_fifo_filled_cnt) begin
        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data
        end
        else if (i <tb_fifo_filled_cnt + wr_port) begin
        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data
        end
        // else dont care
    end
end
endgenerate

always_comb
begin
    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;
    end else begin
        tb_shift = tb_pop_cnt;
    end
end

endmodule"
multi_fifo,multi_fifo_6,"that the FIFO does not experience overflow. Use the signals 'tb_push_cnt', 'tb_pop_cnt, and 'tb_fifo_filled_cnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    |((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) !== 1'b1
);","module multi_fifo_tb (
clk,
reset_,
wr_vld,
wr_data,
wr_ready,
rd_vld,
rd_data,
rd_ready
);

    parameter   max_fifo_entries = 4;
    parameter   wr_port = 1;
    parameter   rd_port = 1;
    parameter   data_width = 1;

    localparam fifo_entry_cntr = $clog2(max_fifo_entries +1 );
    localparam wr_port_log2 = $clog2(wr_port +1 );
    localparam rand_bit_selector = $clog2(data_width);


input clk;
input reset_;
input [(wr_port)-1:0] wr_vld;
input [(data_width * wr_port)-1:0] wr_data;
input [(wr_port)-1:0] wr_ready;
input [(rd_port)-1:0] rd_vld;
input [(data_width * rd_port)-1:0] rd_data;
input [(rd_port)-1:0] rd_ready;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

reg [(fifo_entry_cntr-1):0] tb_wr_ptr;
reg [(fifo_entry_cntr-1):0] tb_rd_ptr;

reg [(wr_port - 1):0] tb_wr_data_for_fv;
reg [(rd_port - 1):0] tb_rd_data_for_fv;

reg [data_width-1:0]tb_wr_data_for_sim[(wr_port - 1):0];
reg [data_width-1:0]tb_rd_data_for_sim[(rd_port - 1):0];



wire [rd_port-1:0] tb_rd_data_is_correct_in_sim_err;
wire tb_fifo_should_not_underflow_err;
wire tb_filled_cnt_less_or_equal_max_entries_err;
wire tb_fifo_should_not_overflow_err;
wire [wr_port-1:0] tb_wr_vld_is_contiguous_err;
wire [wr_port-1:0] tb_wr_ready_is_contiguous_err;
wire [rd_port-1:0] tb_rd_vld_is_contiguous_err;
wire [rd_port-1:0] tb_rd_ready_is_contiguous_err;


wire [rand_bit_selector-1:0] tb_random_1_bit_data_selector[wr_port-1:0]; 
generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_fv
    always_comb
    begin
        tb_wr_data_for_fv[i] = wr_data[(i*data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_fv
    always_comb
    begin
        tb_rd_data_for_fv[i] = rd_data[(i * data_width) + tb_random_1_bit_data_selector[i]];
    end
end
endgenerate

generate
for (genvar i=0; i<wr_port; i++) begin : abstract_write_data_for_sim
    always_comb
    begin
        tb_wr_data_for_sim[i] = wr_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

generate
for (genvar i=0; i<rd_port; i++) begin : abstract_read_data_for_sim
    always_comb
    begin
        tb_rd_data_for_sim[i] = rd_data[((i+1)*data_width)-1 : (i*data_width)];
    end
end
endgenerate

wire [(fifo_entry_cntr-1):0] tb_pop_cnt  = $countones(rd_vld & rd_ready);
wire [(fifo_entry_cntr-1):0] tb_push_cnt = $countones(wr_vld & wr_ready);
wire [(fifo_entry_cntr-1):0] tb_fifo_filled_cnt = tb_wr_ptr - tb_rd_ptr;

wire fifo_will_overflow   = (tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries;

always @(posedge clk)
begin
    if (!reset_) begin
        tb_wr_ptr <= 0;
        tb_rd_ptr <= 0;
    end else begin
        tb_wr_ptr <= tb_wr_ptr + tb_push_cnt; // wr_ptr always move when write
        if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_rd_ptr <= tb_wr_ptr + tb_push_cnt - max_fifo_entries;  // overflow will push rd_ptr
        end else begin
        tb_rd_ptr <= tb_rd_ptr + tb_pop_cnt;  // when not overflow, rd_ptr moves when fifo read
        end
    end
end

reg registered_data;
reg [(fifo_entry_cntr-1):0] registered_ptr;
reg [(wr_port)-1:0] registered_data_next;
reg [(wr_port)-1:0] registered_data_update;

reg [rand_bit_selector-1:0] tb_random_bit_selector_next[wr_port-1:0];
reg [rand_bit_selector-1:0] tb_random_1_bit_data_selector_registered;

always @(posedge clk)
begin
    if (!reset_) begin
        registered_ptr <= 'x;                 // registered_ptr is random during reset
    end else begin
        registered_ptr <= registered_ptr;     // else it retiains its value
    end
end

// when wr_ptr == registered_ptr, register data
generate
for (genvar i=0; i<wr_port; i++) begin:register_write_data
    always_comb
    begin
        registered_data_next[i] = 0;
        registered_data_update[i] = 0;
        tb_random_bit_selector_next[i] = 0;
        if (wr_vld[i] && ((tb_wr_ptr + i[(fifo_entry_cntr-1):0]) == registered_ptr)) begin
            registered_data_update[i] = 1;
            registered_data_next[i] = tb_wr_data_for_fv[i];
            tb_random_bit_selector_next[i] = tb_random_1_bit_data_selector[i];
        end
    end
end
endgenerate

// register selector
reg [wr_port_log2-1:0] wr_index;
reg [rand_bit_selector-1:0] tb_random_bit_next;
always_comb begin
    tb_random_bit_next = 0;
    for (wr_index=0; wr_index < wr_port; wr_index++) begin
        if (registered_data_update[wr_index]) begin
            tb_random_bit_next = tb_random_bit_selector_next[wr_index];
        end
    end
end

// register data
always @ (posedge clk)
begin
    if (|registered_data_update) begin
        registered_data <= |registered_data_next;
        tb_random_1_bit_data_selector_registered <= tb_random_bit_next;
    end
end

reg [data_width-1:0]fifo_data_tracker [(max_fifo_entries+wr_port-1):0];
reg [data_width-1:0]fifo_data_tracker_next [(max_fifo_entries+wr_port-1):0];
reg [(fifo_entry_cntr-1):0] tb_shift;

reg [(fifo_entry_cntr-1):0] n;
always @ (posedge clk)
begin
if (tb_shift == 0) 
    for (n=0; n < max_fifo_entries; n++) begin
        fifo_data_tracker[n] <= fifo_data_tracker_next[n];
    end
else if (tb_shift > (max_fifo_entries+wr_port-1)) begin
  for (n=0; n < max_fifo_entries;n++) fifo_data_tracker[n][data_width-1:0] <= 0;
end else begin
    for (n=0; n<max_fifo_entries; n++) begin 
        if ((tb_shift+n) <= (max_fifo_entries+wr_port-1)) begin
          fifo_data_tracker[n] <= fifo_data_tracker_next[n+tb_shift];
        end
    end  
end
end     

generate
for (genvar i=0; i<(max_fifo_entries+wr_port); i++) begin:assign_data_tracker_next
    always_comb
    begin
        if (i<tb_fifo_filled_cnt) begin
        fifo_data_tracker_next[i] = fifo_data_tracker[i];           // assign kept data
        end
        else if (i <tb_fifo_filled_cnt + wr_port) begin
        fifo_data_tracker_next[i] = tb_wr_data_for_sim[i-tb_fifo_filled_cnt];  // assign new written data
        end
        // else dont care
    end
end
endgenerate

always_comb
begin
    if ((tb_fifo_filled_cnt + tb_push_cnt - tb_pop_cnt) > max_fifo_entries) begin
        tb_shift = tb_push_cnt + tb_fifo_filled_cnt - max_fifo_entries;
    end else begin
        tb_shift = tb_pop_cnt;
    end
end

endmodule"
arbiter_rr,arbiter_0,that the arbiter grant signal is 0-1-hot. Use the signal 'tb_gnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !($onehot0(tb_gnt)) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_3,"that if there is a req, there will be a grant except when busy. Use the signals 'tb_req', 'busy', and 'tb_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (!busy && |tb_req && (tb_gnt == 'd0)) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_4,that each grant must be to a requesting client only. Use the signals 'tb_req' and 'tb_gnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && ((tb_gnt & tb_req) == 'd0)) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_5,"that no grants are made when the arbiter downstream is busy. Use the signals 'tb_gnt', 'hold', 'busy', and 'last_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && busy) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_6,"that the arbiter holds onto grants when there is hold. Use the signals 'tb_gnt', 'hold', and 'tb_req'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    (hold && !busy && (tb_gnt != last_gnt)) !== 1'b1 
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_7,"that the given arbiter follows the Round Robin policy: start with 0th client and keep granting from 0 to n clients one by one except those that are not requesting, then wrap around. Use the signals 'tb_gnt','last_gnt', 'hold', 'valid_request_mask_rr', and 'tb_req'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|last_gnt && |tb_gnt && !hold && (|(valid_request_mask_rr & tb_req))) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_8,"that the first grant of the arbiter follows the Round Robin policy: start with 0th client and keep granting from 0 to n clients one by one except those that are not requesting, then wrap around. Use the signals 'tb_gnt','last_gnt', 'hold', and 'tb_req'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    ((last_gnt === 'd0) && |tb_gnt && ( ((tb_gnt-'d1) & tb_req) !== 'd0)) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_9,"that the arbiter is never on hold or busy or on continued grant at the same time. Use the signals 'tb_req', 'tb_gnt', 'hold', 'valid_request_mask_rr', and 'cont_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !$onehot0({hold,busy,cont_gnt}) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_10,that each grant id is proper. Use the signals 'tb_gnt' and 'gnt_id'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && (tb_gnt[gnt_id] != 1'b1)) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
arbiter_rr,arbiter_11,"that each grant id is proper, for the case where there no grants yet.Use the signals 'tb_gnt' and 'gnt_id'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    ((tb_gnt == 0) && (gnt_id != 0)) !== 1'b1
);","module arbiter_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen


wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

endmodule"
fsm_sequence,fsm_sequence_0,that the specified fsm_sequence is never seen. Use the signal 'tb_sequence_seen'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_sequence_seen) !== 1'b1     
);","module fsm_sequence_tb (
clk, 
reset_, 
fsm_state,
fsm_sequence
);
    parameter fsm_width = 2; //actual width of the states in the RTL
    parameter num_of_states=2; //number of states provided in the fsm_sequence
    parameter num_of_times_initial_state_repeats=1; //Number of times the initial state of the ""fsm_sequence"" is repeated in the ""fsm_sequence""  

input clk;
input reset_;
input [fsm_width-1:0]fsm_state;
input [fsm_width*num_of_states-1:0]fsm_sequence;
wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [fsm_width-1:0] tb_fsm_sequence[num_of_states-1:0]; 

//match the current ""fsm_state"" with the states provided in the ""fsm_sequence""
wire [num_of_states-1:0]match_tracker[num_of_times_initial_state_repeats-1:0]; 
reg [num_of_states-1:0]match_tracker_d1[num_of_times_initial_state_repeats-1:0]; 

//Track all the states of the ""fsm_sequence""
reg [num_of_states-1:0]state_tracker[num_of_times_initial_state_repeats-1:0]; 

reg [fsm_width-1:0] fsm_state_d1;
reg tb_reset_d1;
wire [fsm_width-1:0] tb_random_state;
wire [$clog2(num_of_times_initial_state_repeats):0]tb_sequence_seen;


//storing the states of the fsm_sequence in the correct order
for (genvar i=num_of_states-1; i >=0; i--) begin : storing_of_fsm_states
    assign  tb_fsm_sequence[num_of_states-1-i] = fsm_sequence[(fsm_width*(i+1))-1 : fsm_width*i];
end

//Delayed versions of fsm_state and tb_reset
always @(posedge clk) begin
    if (!reset_) begin
        fsm_state_d1 <= 'd0;
        tb_reset_d1 <= 1;
    end else begin
        fsm_state_d1 <= fsm_state;
        tb_reset_d1 <= tb_reset;  
    end
end

for (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : matching_of_states_as_per_initial_state_repeat
    if (n==0) begin : matching_of_states_for_certain_cases
        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states
            if (i==0) begin : matching_of_states_for_first_state 
                assign match_tracker[n][0] = (fsm_state == tb_fsm_sequence[0]);
            end else begin : matching_of_states_for_other_states 
                assign match_tracker[n][i] = (fsm_state == tb_fsm_sequence[i]);
            end
        end 
    end else begin : matching_of_states_for_other_cases
        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states
            if (i==0) begin : matching_of_states_for_first_state 
            assign match_tracker[n][0] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) 
                                            ? (!(|state_tracker[n]) && (|state_tracker[n-1]) && (fsm_state == tb_fsm_sequence[0])) 
                                            : match_tracker[n][0] ;
            end else begin : matching_of_states_for_other_states
            assign match_tracker[n][i] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) 
                                            ? (!state_tracker[n][i] && state_tracker[n][i-1] && (fsm_state == tb_fsm_sequence[i])) 
                                            : match_tracker[n][i] ;
            end
        end 
    end
end

reg [$clog2(num_of_times_initial_state_repeats):0] j;

always @(posedge clk) begin
    if (!reset_) begin
        for (j=0; j< num_of_times_initial_state_repeats; j++) begin
            state_tracker[j] <= 'd0;
            match_tracker_d1[j] <= 'd0;
        end
    end else begin
        for (j=0; j< num_of_times_initial_state_repeats; j++) begin
            match_tracker_d1[j] <= match_tracker[j];
            if (j==0) 
            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || 
                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && 
                                    (|match_tracker[j] != 'd0)) 
                                        ? state_tracker[j]|match_tracker[j] 
                                        : ((((|match_tracker[j]) == 0) && (fsm_state == tb_fsm_sequence[0])) 
                                            ? 'd1 
                                            : 'd0
                                        );
            else 
            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || 
                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && 
                                    (|match_tracker[j] != 'd0)) 
                                    ? state_tracker[j]|match_tracker[j] 
                                    : 'd0;
        end
    end
end

for (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : fsm_sequence_seen
    assign tb_sequence_seen[n] = state_tracker[n][num_of_states-1];
end

reg check_state_legal_precondition;
always @(posedge clk) begin
    if (!reset_) begin
        check_state_legal_precondition <= 1'b0;
    end else begin
        check_state_legal_precondition <= fsm_state == tb_fsm_sequence[0];
    end
end

endmodule"
fsm_sequence,fsm_sequence_1,that the current FSM state is legal. Use the signals 'check_state_legal_precondition' and 'match_tracker'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (check_state_legal_precondition && !(|(match_tracker[0]))) !== 1'b1     
);","module fsm_sequence_tb (
clk, 
reset_, 
fsm_state,
fsm_sequence
);
    parameter fsm_width = 2; //actual width of the states in the RTL
    parameter num_of_states=2; //number of states provided in the fsm_sequence
    parameter num_of_times_initial_state_repeats=1; //Number of times the initial state of the ""fsm_sequence"" is repeated in the ""fsm_sequence""  

input clk;
input reset_;
input [fsm_width-1:0]fsm_state;
input [fsm_width*num_of_states-1:0]fsm_sequence;
wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [fsm_width-1:0] tb_fsm_sequence[num_of_states-1:0]; 

//match the current ""fsm_state"" with the states provided in the ""fsm_sequence""
wire [num_of_states-1:0]match_tracker[num_of_times_initial_state_repeats-1:0]; 
reg [num_of_states-1:0]match_tracker_d1[num_of_times_initial_state_repeats-1:0]; 

//Track all the states of the ""fsm_sequence""
reg [num_of_states-1:0]state_tracker[num_of_times_initial_state_repeats-1:0]; 

reg [fsm_width-1:0] fsm_state_d1;
reg tb_reset_d1;
wire [fsm_width-1:0] tb_random_state;
wire [$clog2(num_of_times_initial_state_repeats):0]tb_sequence_seen;


//storing the states of the fsm_sequence in the correct order
for (genvar i=num_of_states-1; i >=0; i--) begin : storing_of_fsm_states
    assign  tb_fsm_sequence[num_of_states-1-i] = fsm_sequence[(fsm_width*(i+1))-1 : fsm_width*i];
end

//Delayed versions of fsm_state and tb_reset
always @(posedge clk) begin
    if (!reset_) begin
        fsm_state_d1 <= 'd0;
        tb_reset_d1 <= 1;
    end else begin
        fsm_state_d1 <= fsm_state;
        tb_reset_d1 <= tb_reset;  
    end
end

for (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : matching_of_states_as_per_initial_state_repeat
    if (n==0) begin : matching_of_states_for_certain_cases
        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states
            if (i==0) begin : matching_of_states_for_first_state 
                assign match_tracker[n][0] = (fsm_state == tb_fsm_sequence[0]);
            end else begin : matching_of_states_for_other_states 
                assign match_tracker[n][i] = (fsm_state == tb_fsm_sequence[i]);
            end
        end 
    end else begin : matching_of_states_for_other_cases
        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states
            if (i==0) begin : matching_of_states_for_first_state 
            assign match_tracker[n][0] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) 
                                            ? (!(|state_tracker[n]) && (|state_tracker[n-1]) && (fsm_state == tb_fsm_sequence[0])) 
                                            : match_tracker[n][0] ;
            end else begin : matching_of_states_for_other_states
            assign match_tracker[n][i] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) 
                                            ? (!state_tracker[n][i] && state_tracker[n][i-1] && (fsm_state == tb_fsm_sequence[i])) 
                                            : match_tracker[n][i] ;
            end
        end 
    end
end

reg [$clog2(num_of_times_initial_state_repeats):0] j;

always @(posedge clk) begin
    if (!reset_) begin
        for (j=0; j< num_of_times_initial_state_repeats; j++) begin
            state_tracker[j] <= 'd0;
            match_tracker_d1[j] <= 'd0;
        end
    end else begin
        for (j=0; j< num_of_times_initial_state_repeats; j++) begin
            match_tracker_d1[j] <= match_tracker[j];
            if (j==0) 
            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || 
                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && 
                                    (|match_tracker[j] != 'd0)) 
                                        ? state_tracker[j]|match_tracker[j] 
                                        : ((((|match_tracker[j]) == 0) && (fsm_state == tb_fsm_sequence[0])) 
                                            ? 'd1 
                                            : 'd0
                                        );
            else 
            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || 
                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && 
                                    (|match_tracker[j] != 'd0)) 
                                    ? state_tracker[j]|match_tracker[j] 
                                    : 'd0;
        end
    end
end

for (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : fsm_sequence_seen
    assign tb_sequence_seen[n] = state_tracker[n][num_of_states-1];
end

reg check_state_legal_precondition;
always @(posedge clk) begin
    if (!reset_) begin
        check_state_legal_precondition <= 1'b0;
    end else begin
        check_state_legal_precondition <= fsm_state == tb_fsm_sequence[0];
    end
end

endmodule"
fsm_sequence,fsm_sequence_3,"that if the current FSM state is legal, the FSM should not continue to be the same legal state. Use the signals 'fsm_state', 'tb_random_state', and 'tb_fsm_sequence'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (fsm_state == tb_random_state) |-> strong(##[1:$] (fsm_state != tb_random_state)) 
);","module fsm_sequence_tb (
clk, 
reset_, 
fsm_state,
fsm_sequence
);
    parameter fsm_width = 2; //actual width of the states in the RTL
    parameter num_of_states=2; //number of states provided in the fsm_sequence
    parameter num_of_times_initial_state_repeats=1; //Number of times the initial state of the ""fsm_sequence"" is repeated in the ""fsm_sequence""  

input clk;
input reset_;
input [fsm_width-1:0]fsm_state;
input [fsm_width*num_of_states-1:0]fsm_sequence;
wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [fsm_width-1:0] tb_fsm_sequence[num_of_states-1:0]; 

//match the current ""fsm_state"" with the states provided in the ""fsm_sequence""
wire [num_of_states-1:0]match_tracker[num_of_times_initial_state_repeats-1:0]; 
reg [num_of_states-1:0]match_tracker_d1[num_of_times_initial_state_repeats-1:0]; 

//Track all the states of the ""fsm_sequence""
reg [num_of_states-1:0]state_tracker[num_of_times_initial_state_repeats-1:0]; 

reg [fsm_width-1:0] fsm_state_d1;
reg tb_reset_d1;
wire [fsm_width-1:0] tb_random_state;
wire [$clog2(num_of_times_initial_state_repeats):0]tb_sequence_seen;


//storing the states of the fsm_sequence in the correct order
for (genvar i=num_of_states-1; i >=0; i--) begin : storing_of_fsm_states
    assign  tb_fsm_sequence[num_of_states-1-i] = fsm_sequence[(fsm_width*(i+1))-1 : fsm_width*i];
end

//Delayed versions of fsm_state and tb_reset
always @(posedge clk) begin
    if (!reset_) begin
        fsm_state_d1 <= 'd0;
        tb_reset_d1 <= 1;
    end else begin
        fsm_state_d1 <= fsm_state;
        tb_reset_d1 <= tb_reset;  
    end
end

for (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : matching_of_states_as_per_initial_state_repeat
    if (n==0) begin : matching_of_states_for_certain_cases
        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states
            if (i==0) begin : matching_of_states_for_first_state 
                assign match_tracker[n][0] = (fsm_state == tb_fsm_sequence[0]);
            end else begin : matching_of_states_for_other_states 
                assign match_tracker[n][i] = (fsm_state == tb_fsm_sequence[i]);
            end
        end 
    end else begin : matching_of_states_for_other_cases
        for (genvar i=0; i<num_of_states; i++) begin : matching_of_states_as_per_num_of_states
            if (i==0) begin : matching_of_states_for_first_state 
            assign match_tracker[n][0] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) 
                                            ? (!(|state_tracker[n]) && (|state_tracker[n-1]) && (fsm_state == tb_fsm_sequence[0])) 
                                            : match_tracker[n][0] ;
            end else begin : matching_of_states_for_other_states
            assign match_tracker[n][i] = ((fsm_state != fsm_state_d1) && !tb_reset_d1) 
                                            ? (!state_tracker[n][i] && state_tracker[n][i-1] && (fsm_state == tb_fsm_sequence[i])) 
                                            : match_tracker[n][i] ;
            end
        end 
    end
end

reg [$clog2(num_of_times_initial_state_repeats):0] j;

always @(posedge clk) begin
    if (!reset_) begin
        for (j=0; j< num_of_times_initial_state_repeats; j++) begin
            state_tracker[j] <= 'd0;
            match_tracker_d1[j] <= 'd0;
        end
    end else begin
        for (j=0; j< num_of_times_initial_state_repeats; j++) begin
            match_tracker_d1[j] <= match_tracker[j];
            if (j==0) 
            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || 
                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && 
                                    (|match_tracker[j] != 'd0)) 
                                        ? state_tracker[j]|match_tracker[j] 
                                        : ((((|match_tracker[j]) == 0) && (fsm_state == tb_fsm_sequence[0])) 
                                            ? 'd1 
                                            : 'd0
                                        );
            else 
            state_tracker[j] <= (((state_tracker[j]==(match_tracker[j]-1'b1)) || 
                                    (state_tracker[j] == ((match_tracker[j]-1'b1) | match_tracker[j]))) && 
                                    (|match_tracker[j] != 'd0)) 
                                    ? state_tracker[j]|match_tracker[j] 
                                    : 'd0;
        end
    end
end

for (genvar n=0; n<num_of_times_initial_state_repeats; n++) begin : fsm_sequence_seen
    assign tb_sequence_seen[n] = state_tracker[n][num_of_states-1];
end

reg check_state_legal_precondition;
always @(posedge clk) begin
    if (!reset_) begin
        check_state_legal_precondition <= 1'b0;
    end else begin
        check_state_legal_precondition <= fsm_state == tb_fsm_sequence[0];
    end
end

endmodule"
arbiter_sticky_rr,arbiter_0,that the arbiter grant signal is 0-1-hot. Use the signal 'tb_gnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !($onehot0(tb_gnt)) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_3,"that if there is a req, there will be a grant except when busy. Use the signals 'tb_req', 'busy', and 'tb_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (!busy && |tb_req && (tb_gnt == 'd0)) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_4,that each grant must be to a requesting client only. Use the signals 'tb_req' and 'tb_gnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && ((tb_gnt & tb_req) == 'd0)) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_5,"that no grants are made when the arbiter downstream is busy. Use the signals 'tb_gnt', 'hold', 'busy', and 'last_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && busy) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_6,"that the arbiter holds onto grants when there is hold. Use the signals 'tb_gnt', 'hold', and 'tb_req'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (hold && !busy && (tb_gnt != last_gnt)) !== 1'b1 
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_12,"that no grants are given while there is a grant bubble. Use the signals 'tb_gnt', 'tb_req', 'sticky_req', and 'arbiter_in_sticky'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (arbiter_in_sticky && !(|(sticky_req & tb_req)) && (tb_gnt != 'd0)) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_13,"that the grant of the arbiter stays sticky, i.e.  if sticky bit is high (hold) then keep granting the same client. Use the signals 'tb_gnt', 'sticky_req', and 'arbiter_in_sticky'","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (arbiter_in_sticky && (tb_gnt != 'd0) && (tb_gnt != sticky_req)) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_9,"that the arbiter is never on hold or busy or on continued grant at the same time. Use the signals 'tb_req', 'tb_gnt', 'hold', 'valid_request_mask_rr', and 'cont_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !$onehot0({hold,busy,cont_gnt}) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_10,that each grant id is proper. Use the signals 'tb_gnt' and 'gnt_id'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && (tb_gnt[gnt_id] != 1'b1)) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_rr,arbiter_11,"that each grant id is proper, for the case where there no grants yet.Use the signals 'tb_gnt' and 'gnt_id'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    ((tb_gnt == 0) && (gnt_id != 0)) !== 1'b1
);","module arbiter_sticky_rr_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

wire [NUM_OF_CLIENTS-1 : 0] valid_request_mask_rr = (last_gnt < tb_gnt) ? (tb_gnt - last_gnt - last_gnt) : (
                                                (last_gnt > tb_gnt) ? ~(last_gnt - tb_gnt | last_gnt) :
                                                ~tb_gnt);

reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
genvar i;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
fifo_1r1w_pattern,fifo_0,"that the FIFO does not underflow, assuming no bypass. Use the signals 'rd_pop' and 'fifo_empty'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    (fifo_empty && rd_pop) !== 1'b1
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

wire colour_1bit;                          // pattern
wire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only
asum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)
$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)
);
reg [FIFO_DEPTH_log2:0] rd_pending_ctr; 
reg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead
reg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead
wire fifo_empty;
always @(posedge clk) begin
    // ---- input fsm ----
    if (!reset_) begin
        input_fsm <= 2'd0;
    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        input_fsm <= 2'd1; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        input_fsm <= 2'd2; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        input_fsm <= 2'd3; 
    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        input_fsm <= 2'd3; 
    end else begin
        input_fsm <= input_fsm; 
    end
    // ---- output fsm ----
    if (!reset_) begin
        output_fsm <= 2'd0;
    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        output_fsm <= 2'd1; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        output_fsm <= 2'd2; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        output_fsm <= 2'd3; 
    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        output_fsm <= 2'd3; 
    end else begin
        output_fsm <= output_fsm; 
    end
    // ---- pending counter ----
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
end
assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;

endmodule"
fifo_1r1w_pattern,fifo_1,"that the FIFO does not overflow, assuming no bypass. Use the signals 'wr_push' and 'fifo_full'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    (fifo_full && wr_push) !== 1'b1
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

wire colour_1bit;                          // pattern
wire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only
asum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)
$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)
);
reg [FIFO_DEPTH_log2:0] rd_pending_ctr; 
reg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead
reg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead
wire fifo_empty;
always @(posedge clk) begin
    // ---- input fsm ----
    if (!reset_) begin
        input_fsm <= 2'd0;
    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        input_fsm <= 2'd1; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        input_fsm <= 2'd2; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        input_fsm <= 2'd3; 
    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        input_fsm <= 2'd3; 
    end else begin
        input_fsm <= input_fsm; 
    end
    // ---- output fsm ----
    if (!reset_) begin
        output_fsm <= 2'd0;
    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        output_fsm <= 2'd1; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        output_fsm <= 2'd2; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        output_fsm <= 2'd3; 
    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        output_fsm <= 2'd3; 
    end else begin
        output_fsm <= output_fsm; 
    end
    // ---- pending counter ----
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
end
assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;

endmodule"
fifo_1r1w_pattern,fifo_2,"that the fifo output and read data are consistent, assuming no bypass. Use the signals 'input_fsm', 'output_fsm', 'rd_pop', 'rd_data', 'rand_bit_sel', and 'colour_1bit'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (((input_fsm == 2'd2) && (output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) || ((input_fsm == 2'd2) && (output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit))) !== 1'b1
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

wire colour_1bit;                          // pattern
wire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only
asum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)
$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)
);
reg [FIFO_DEPTH_log2:0] rd_pending_ctr; 
reg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead
reg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead
wire fifo_empty;
always @(posedge clk) begin
    // ---- input fsm ----
    if (!reset_) begin
        input_fsm <= 2'd0;
    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        input_fsm <= 2'd1; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        input_fsm <= 2'd2; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        input_fsm <= 2'd3; 
    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        input_fsm <= 2'd3; 
    end else begin
        input_fsm <= input_fsm; 
    end
    // ---- output fsm ----
    if (!reset_) begin
        output_fsm <= 2'd0;
    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        output_fsm <= 2'd1; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        output_fsm <= 2'd2; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        output_fsm <= 2'd3; 
    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        output_fsm <= 2'd3; 
    end else begin
        output_fsm <= output_fsm; 
    end
    // ---- pending counter ----
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
end
assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;

endmodule"
fifo_1r1w_pattern,fifo_3,"that when response is pending, data is eventually popped from the FIFO. Use the signals 'rd_pop' and 'fifo_empty'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !fifo_empty |-> strong(##[0:$] rd_pop)
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

wire colour_1bit;                          // pattern
wire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only
asum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)
$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)
);
reg [FIFO_DEPTH_log2:0] rd_pending_ctr; 
reg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead
reg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead
wire fifo_empty;
always @(posedge clk) begin
    // ---- input fsm ----
    if (!reset_) begin
        input_fsm <= 2'd0;
    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        input_fsm <= 2'd1; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        input_fsm <= 2'd2; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        input_fsm <= 2'd3; 
    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        input_fsm <= 2'd3; 
    end else begin
        input_fsm <= input_fsm; 
    end
    // ---- output fsm ----
    if (!reset_) begin
        output_fsm <= 2'd0;
    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        output_fsm <= 2'd1; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        output_fsm <= 2'd2; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        output_fsm <= 2'd3; 
    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        output_fsm <= 2'd3; 
    end else begin
        output_fsm <= output_fsm; 
    end
    // ---- pending counter ----
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
end
assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;

endmodule"
fifo_1r1w_pattern,fifo_4,"that when there is a write push to the FIFO, data is eventually popped. Use the signals 'rd_pop' and 'wr_push'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    wr_push |-> strong(##[0:$] rd_pop)
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

wire colour_1bit;                          // pattern
wire [DATA_WIDTH_log2-1:0] rand_bit_sel;   // do this on one bit of fifo only
asum_tb_inorder__rand_stable: assume property (@(posedge clk) disable iff (!reset_)
$stable(colour_1bit) && $stable(rand_bit_sel) && (rand_bit_sel < DATA_WIDTH)
);
reg [FIFO_DEPTH_log2:0] rd_pending_ctr; 
reg [1:0] input_fsm; //0 - init, 1- 1st seen, 2 - 2nd seen, 3 - dead
reg [2:0] output_fsm; //0 - init, 1- 1st seen, 2 - nth seen, 3 - dead
wire fifo_empty;
always @(posedge clk) begin
    // ---- input fsm ----
    if (!reset_) begin
        input_fsm <= 2'd0;
    end else if ((input_fsm == 2'd0) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        input_fsm <= 2'd1; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        input_fsm <= 2'd2; 
    end else if ((input_fsm == 2'd1) && wr_push && (wr_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        input_fsm <= 2'd3; 
    end else if ((input_fsm == 2'd2) && wr_push && (wr_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        input_fsm <= 2'd3; 
    end else begin
        input_fsm <= input_fsm; 
    end
    // ---- output fsm ----
    if (!reset_) begin
        output_fsm <= 2'd0;
    end else if ((output_fsm == 2'd0) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //init state -> seen 1st state
        output_fsm <= 2'd1; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 1st state -> seen 2nd state
        output_fsm <= 2'd2; 
    end else if ((output_fsm == 2'd1) && rd_pop && (rd_data[rand_bit_sel] != colour_1bit)) begin //seen 1st state -> dead state
        output_fsm <= 2'd3; 
    end else if ((output_fsm == 2'd2) && rd_pop && (rd_data[rand_bit_sel] == colour_1bit)) begin //seen 2nd state -> dead state
        output_fsm <= 2'd3; 
    end else begin
        output_fsm <= output_fsm; 
    end
    // ---- pending counter ----
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
end
assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;

endmodule"
arbiter_sticky_lru,arbiter_0,that the arbiter grant signal is 0-1-hot. Use the signal 'tb_gnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !($onehot0(tb_gnt)) !== 1'b1
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_lru,arbiter_3,"that if there is a req, there will be a grant except when busy. Use the signals 'tb_req', 'busy', and 'tb_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (!busy && |tb_req && (tb_gnt == 'd0)) !== 1'b1
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_lru,arbiter_4,that each grant must be to a requesting client only. Use the signals 'tb_req' and 'tb_gnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && ((tb_gnt & tb_req) == 'd0)) !== 1'b1
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_lru,arbiter_5,"that no grants are made when the arbiter downstream is busy. Use the signals 'tb_gnt', 'hold', 'busy', and 'last_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && busy) !== 1'b1
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_lru,arbiter_6,"that the arbiter holds onto grants when there is hold. Use the signals 'tb_gnt', 'hold', and 'tb_req'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (hold && !busy && (tb_gnt != last_gnt)) !== 1'b1 
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_lru,arbiter_13,"that the grant of the arbiter stays sticky, i.e.  if sticky bit is high (hold) then keep granting the same client. Use the signals 'tb_gnt', 'sticky_req', and 'arbiter_in_sticky'","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (arbiter_in_sticky && (tb_gnt != 'd0) && (tb_gnt != sticky_req)) !== 1'b1
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_lru,arbiter_9,"that the arbiter is never on hold or busy or on continued grant at the same time. Use the signals 'tb_req', 'tb_gnt', 'hold', 'valid_request_mask_rr', and 'cont_gnt'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !$onehot0({hold,busy,cont_gnt}) !== 1'b1
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_lru,arbiter_10,that each grant id is proper. Use the signals 'tb_gnt' and 'gnt_id'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (|tb_gnt && (tb_gnt[gnt_id] != 1'b1)) !== 1'b1
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
arbiter_sticky_lru,arbiter_11,"that each grant id is proper, for the case where there no grants yet.Use the signals 'tb_gnt' and 'gnt_id'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    ((tb_gnt == 0) && (gnt_id != 0)) !== 1'b1
);","module arbiter_sticky_lru_tb (
clk, reset_, req, gnt, gnt_id, busy, hold, cont_gnt);

    parameter       NUM_OF_CLIENTS = 6;

localparam tb_num_client_req_width = $clog2(NUM_OF_CLIENTS); 
localparam busy_latency_width = $clog2(NUM_OF_CLIENTS);
localparam cont_gnt_latency_width = $clog2(NUM_OF_CLIENTS);
localparam hold_latency_width = $clog2(NUM_OF_CLIENTS);

input clk;
input reset_;//clock and reset
input busy; //busy 
input hold;//hold
input [NUM_OF_CLIENTS-1 : 0] req;
input [NUM_OF_CLIENTS-1 : 0] gnt;//request and grant. grant is assumed to be one hot.
input [tb_num_client_req_width-1:0] gnt_id;
input cont_gnt; //same as cont_gnt from arbgen

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);

wire [NUM_OF_CLIENTS-1 : 0] tb_req;
wire [NUM_OF_CLIENTS-1 : 0] tb_gnt;
wire [NUM_OF_CLIENTS-1 : 0] tb_req_for_starvation;
wire [NUM_OF_CLIENTS-1 : 0] tb_hold;

reg [NUM_OF_CLIENTS-1 : 0] sticky_req;
reg arbiter_in_sticky;

genvar a;
assign tb_req = req;
assign tb_gnt = gnt;
assign tb_req_for_starvation = req;
assign tb_hold = hold;

reg [NUM_OF_CLIENTS-1 : 0] last_gnt;
always @(posedge clk) begin
    if (!reset_) begin 
        last_gnt <= 0; 
   end else if (|tb_gnt && !cont_gnt) begin 
        last_gnt <= tb_gnt; 
    end
end

// sticky model    
always @(posedge clk) begin
    if (!reset_) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end else if (|(tb_gnt & tb_req & tb_hold)) begin 
        arbiter_in_sticky <= 1'b1;
        sticky_req <= tb_gnt & tb_req & tb_hold;
    end else if (|(tb_gnt & tb_req & ~tb_hold)) begin 
        arbiter_in_sticky <= 1'b0;
        sticky_req <= 'd0;
    end
end    

reg [tb_num_client_req_width:0] lru [NUM_OF_CLIENTS-1:0];
wire [tb_num_client_req_width:0] lru_gnt_num;
reg [tb_num_client_req_width:0] temp_lru_gnt_num_reg;

assign lru_gnt_num = temp_lru_gnt_num_reg;

always_comb begin
    temp_lru_gnt_num_reg = 'd0;
    for (int k=0; k<NUM_OF_CLIENTS; k++) begin
        if (tb_gnt[k]) begin
            temp_lru_gnt_num_reg = lru[k];
        end
    end
end
genvar i;
reg [NUM_OF_CLIENTS-1 : 0] req_seen_flag;
for (i = 0; i < NUM_OF_CLIENTS; i++) begin
    always @(posedge clk) begin
        if (!reset_) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i] && tb_gnt[i]) begin req_seen_flag[i] <= 0; end
        else if (tb_req_for_starvation[i]) begin req_seen_flag[i] <= 1; end
        else if (tb_gnt[i]) begin req_seen_flag[i] <= 0; end
    end
end


endmodule"
fifo_1r1w_random,fifo_0,"that the FIFO does not underflow, assuming no bypass. Use the signals 'rd_pop' and 'fifo_empty'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    (fifo_empty && rd_pop) !== 1'b1
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks
reg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter
wire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next
reg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data
wire                     rand_pulse;                // random pulse which picks the packet
reg                      rand_pulse_seen;           // to make sure we do this check only once
wire                     fifo_empty;

assign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;
always @(posedge clk) begin
    if (!reset_) begin
        rand_pulse_seen <= 1'b0;
    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin
        rand_pulse_seen <= 1'b1;
        free_selected_data <= wr_data;
    end else begin
        rand_pulse_seen <= rand_pulse_seen;
        free_selected_data <= free_selected_data;
    end
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
    if (!reset_) begin
        rand_packet_tracker <= 'd0;
    end else begin
        rand_packet_tracker <= rand_packet_tracker_next;
    end
end

assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;


endmodule"
fifo_1r1w_random,fifo_1,"that the FIFO does not overflow, assuming no bypass. Use the signals 'wr_push' and 'fifo_full'.","asrt : assert property (@(posedge clk) disable iff (tb_reset)
    (fifo_full && wr_push) !== 1'b1
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks
reg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter
wire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next
reg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data
wire                     rand_pulse;                // random pulse which picks the packet
reg                      rand_pulse_seen;           // to make sure we do this check only once
wire                     fifo_empty;

assign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;
always @(posedge clk) begin
    if (!reset_) begin
        rand_pulse_seen <= 1'b0;
    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin
        rand_pulse_seen <= 1'b1;
        free_selected_data <= wr_data;
    end else begin
        rand_pulse_seen <= rand_pulse_seen;
        free_selected_data <= free_selected_data;
    end
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
    if (!reset_) begin
        rand_packet_tracker <= 'd0;
    end else begin
        rand_packet_tracker <= rand_packet_tracker_next;
    end
end

assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;


endmodule"
fifo_1r1w_random,fifo_2,"that the fifo output and read data are consistent, assuming no bypass. Use the signals 'rd_pop', 'rd_data', 'rand_packet_tracker', 'rand_packet_tracker_next', 'free_selected_data', and 'rand_pulse_seen'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
       (rd_pop && (free_selected_data != rd_data) && (rand_packet_tracker_next == 'd0) && (rand_packet_tracker != 'd0) && rand_pulse_seen) !== 1'b1
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks
reg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter
wire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next
reg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data
wire                     rand_pulse;                // random pulse which picks the packet
reg                      rand_pulse_seen;           // to make sure we do this check only once
wire                     fifo_empty;

assign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;
always @(posedge clk) begin
    if (!reset_) begin
        rand_pulse_seen <= 1'b0;
    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin
        rand_pulse_seen <= 1'b1;
        free_selected_data <= wr_data;
    end else begin
        rand_pulse_seen <= rand_pulse_seen;
        free_selected_data <= free_selected_data;
    end
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
    if (!reset_) begin
        rand_packet_tracker <= 'd0;
    end else begin
        rand_packet_tracker <= rand_packet_tracker_next;
    end
end

assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;


endmodule"
fifo_1r1w_random,fifo_3,"that when response is pending, data is eventually popped from the FIFO. Use the signals 'rd_pop' and 'fifo_empty'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !fifo_empty |-> strong(##[0:$] rd_pop)
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks
reg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter
wire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next
reg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data
wire                     rand_pulse;                // random pulse which picks the packet
reg                      rand_pulse_seen;           // to make sure we do this check only once
wire                     fifo_empty;

assign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;
always @(posedge clk) begin
    if (!reset_) begin
        rand_pulse_seen <= 1'b0;
    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin
        rand_pulse_seen <= 1'b1;
        free_selected_data <= wr_data;
    end else begin
        rand_pulse_seen <= rand_pulse_seen;
        free_selected_data <= free_selected_data;
    end
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
    if (!reset_) begin
        rand_packet_tracker <= 'd0;
    end else begin
        rand_packet_tracker <= rand_packet_tracker_next;
    end
end

assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;


endmodule"
fifo_1r1w_random,fifo_4,"that when there is a write push to the FIFO, data is eventually popped. Use the signals 'rd_pop' and 'wr_push'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    wr_push |-> strong(##[0:$] rd_pop)
);","module fifo_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [FIFO_DEPTH_log2:0]  rd_pending_ctr;            // this is the true counter for overflow/underflow checks
reg [FIFO_DEPTH_log2:0]  rand_packet_tracker;       // pending counter
wire [FIFO_DEPTH_log2:0] rand_packet_tracker_next;  // pending counter next
reg [DATA_WIDTH-1:0]     free_selected_data;        // randomly picked data
wire                     rand_pulse;                // random pulse which picks the packet
reg                      rand_pulse_seen;           // to make sure we do this check only once
wire                     fifo_empty;

assign rand_packet_tracker_next = (rand_packet_tracker == 'd0) && rand_pulse_seen ? 'd0 : rand_packet_tracker + (wr_push && !rand_pulse_seen) - rd_pop;
always @(posedge clk) begin
    if (!reset_) begin
        rand_pulse_seen <= 1'b0;
    end else if (rand_pulse && wr_push && !rand_pulse_seen) begin
        rand_pulse_seen <= 1'b1;
        free_selected_data <= wr_data;
    end else begin
        rand_pulse_seen <= rand_pulse_seen;
        free_selected_data <= free_selected_data;
    end
    if (!reset_) begin
        rd_pending_ctr <= 'd0;
    end else begin
        rd_pending_ctr <= rd_pending_ctr + wr_push - rd_pop;
    end
    if (!reset_) begin
        rand_packet_tracker <= 'd0;
    end else begin
        rand_packet_tracker <= rand_packet_tracker_next;
    end
end

assign fifo_full = rd_pending_ctr == (FIFO_DEPTH);
assign fifo_empty = rd_pending_ctr == 'd0;


endmodule"
fifo_1r1w_bypass,fifo_0,"that the FIFO does not underflow, assuming no bypass. Use the signals 'rd_pop' and 'fifo_empty'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (fifo_empty && rd_pop && (!wr_push || (wr_data != rd_data))) !== 1'b1
);","module fifo_with_bypass_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];


endmodule"
fifo_1r1w_bypass,fifo_1,"that the FIFO does not overflow, assuming no bypass. Use the signals 'wr_push' and 'fifo_full'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (fifo_full && wr_push && !rd_pop) !== 1'b1
);","module fifo_with_bypass_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];


endmodule"
fifo_1r1w_bypass,fifo_2,"that the fifo output and read data are consistent, assuming no bypass. Use the signals 'rd_pop', 'rd_data', 'wr_push', 'wr_data', 'fifo_empty', and 'fifo_out_data'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (!fifo_empty && rd_pop && (fifo_out_data != rd_data)) || (fifo_empty && rd_pop && wr_push && (wr_data != rd_data)) !== 1'b1
);","module fifo_with_bypass_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];


endmodule"
fifo_1r1w_bypass,fifo_3,"that when response is pending, data is eventually popped from the FIFO. Use the signals 'rd_pop' and 'fifo_empty'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    !fifo_empty |-> strong(##[0:$] rd_pop)
);","module fifo_with_bypass_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];


endmodule"
fifo_1r1w_bypass,fifo_4,"that when there is a write push to the FIFO, data is eventually popped. Use the signals 'rd_pop' and 'wr_push'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    wr_push |-> strong(##[0:$] rd_pop)
);","module fifo_with_bypass_tb (
     clk,
     reset_,
     wr_vld,
     wr_data,
     wr_ready,
     rd_vld,
     rd_data,
     rd_ready
   );
  
    parameter   FIFO_DEPTH                              = 4;
    parameter   DATA_WIDTH                              = 1;

localparam FIFO_DEPTH_log2 = $clog2(FIFO_DEPTH); 
localparam DATA_WIDTH_log2 = $clog2(DATA_WIDTH); 

    input                   clk;
    input                   reset_;
    input                   wr_vld;
    input  [DATA_WIDTH-1:0] wr_data;
    input                   wr_ready;
    input                   rd_vld;
    input  [DATA_WIDTH-1:0] rd_data;
    input                   rd_ready;

wire wr_push;
wire rd_pop;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire fifo_full;
assign wr_push = wr_vld && wr_ready;
assign rd_pop = rd_vld && rd_ready; 

reg [DATA_WIDTH-1:0]             fifo_array [FIFO_DEPTH-1:0]; //fifo array - shift register
reg [FIFO_DEPTH_log2-1:0]        fifo_rd_ptr;                 //fifo array - rd_ptr
wire                             actual_fifo_pop;             // actual pop == pop
reg                              fifo_empty;                  // fifo empty
wire [DATA_WIDTH-1:0]            fifo_out_data;               // dout

always @(posedge clk) begin
    if (!reset_) fifo_array[0] <= 'd0;
    else if (wr_push) begin
        fifo_array[0] <= wr_data;
    end else fifo_array[0] <= fifo_array[0];
end
for (genvar i = 1; i < FIFO_DEPTH; i++ ) begin : loop_id
    always @(posedge clk) begin
        if (!reset_) fifo_array[i] <= 'd0;
        else if (wr_push) begin
            fifo_array[i] <= fifo_array[i-1];
        end else fifo_array[i] <= fifo_array[i];
    end
end

always @(posedge clk) begin
    if (!reset_) begin
        fifo_rd_ptr <= 'd0;
    end else if (wr_push && fifo_empty)  begin
        fifo_rd_ptr <= 'd0;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0)) begin
        fifo_rd_ptr <= 'd0;
    end else begin
        fifo_rd_ptr <= fifo_rd_ptr + wr_push - rd_pop;
    end
    if (!reset_) begin
        fifo_empty <= 'd1;
    end else if (rd_pop && !fifo_empty && (fifo_rd_ptr == 'd0) && !wr_push) begin
        fifo_empty <= 'd1;
    end else if ((fifo_rd_ptr != 'd0) || wr_push && !rd_pop) begin
        fifo_empty <= 'd0;
    end
end
assign fifo_full = (fifo_rd_ptr == (FIFO_DEPTH - 1)) && !fifo_empty;
assign fifo_out_data = fifo_array[fifo_rd_ptr];


endmodule"
ram,ram_0,read address is not greater than number of entries i.e. the read address is not pointing to an address not in the memory. Use the signals 're' and 'ra'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (re |-> ra < entries)
);","module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);

  
    parameter   addr_width = 1;
    parameter   data_width = 1;
    parameter   entries = 1;
    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check


parameter tb_max_length_width = $clog2(wr_latency);

input    clk,reset_;
input    we,re;
input [addr_width-1:0] wa,ra;
input [data_width-1:0] wd,rd;
input    stall;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [addr_width-1:0] symbolic_constant_a;
asum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)
  ($stable(symbolic_constant_a))
);

reg addr_ar_seen;
reg addr_aw_seen;
reg addr_first_aw_seen;
reg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       

always @(posedge clk) begin
  if(!reset_) begin
    addr_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd1;    
  end else if (re && (ra == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd0;    
  end
end
always @(posedge clk) begin
  if(!reset_) begin
    addr_ar_seen <= 1'd0;
  end else if (we && (re == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd1;    
  end else if (re && (we == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd0;    
  end
end

always @(posedge clk) begin
  if(!reset_) begin
    addr_first_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_first_aw_seen <= 1'd1;
  end
end

always @(posedge clk) begin
    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;
end


endmodule"
ram,ram_1,write address is not greater than number of entries i.e. the write address is not pointing to an address not in the memory. Use the signals 'we' and 'wa'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (we |-> wa < entries)
);","module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);

  
    parameter   addr_width = 1;
    parameter   data_width = 1;
    parameter   entries = 1;
    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check


parameter tb_max_length_width = $clog2(wr_latency);

input    clk,reset_;
input    we,re;
input [addr_width-1:0] wa,ra;
input [data_width-1:0] wd,rd;
input    stall;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [addr_width-1:0] symbolic_constant_a;
asum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)
  ($stable(symbolic_constant_a))
);

reg addr_ar_seen;
reg addr_aw_seen;
reg addr_first_aw_seen;
reg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       

always @(posedge clk) begin
  if(!reset_) begin
    addr_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd1;    
  end else if (re && (ra == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd0;    
  end
end
always @(posedge clk) begin
  if(!reset_) begin
    addr_ar_seen <= 1'd0;
  end else if (we && (re == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd1;    
  end else if (re && (we == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd0;    
  end
end

always @(posedge clk) begin
  if(!reset_) begin
    addr_first_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_first_aw_seen <= 1'd1;
  end
end

always @(posedge clk) begin
    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;
end


endmodule"
ram,ram_2,"write through violation, where   a read from and a write to thesame address happen in same cycle, does not occur. Use the signals 'we', 'wa', 're' and 'ra'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (we && re |-> !(wa == ra))
);","module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);

  
    parameter   addr_width = 1;
    parameter   data_width = 1;
    parameter   entries = 1;
    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check


parameter tb_max_length_width = $clog2(wr_latency);

input    clk,reset_;
input    we,re;
input [addr_width-1:0] wa,ra;
input [data_width-1:0] wd,rd;
input    stall;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [addr_width-1:0] symbolic_constant_a;
asum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)
  ($stable(symbolic_constant_a))
);

reg addr_ar_seen;
reg addr_aw_seen;
reg addr_first_aw_seen;
reg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       

always @(posedge clk) begin
  if(!reset_) begin
    addr_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd1;    
  end else if (re && (ra == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd0;    
  end
end
always @(posedge clk) begin
  if(!reset_) begin
    addr_ar_seen <= 1'd0;
  end else if (we && (re == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd1;    
  end else if (re && (we == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd0;    
  end
end

always @(posedge clk) begin
  if(!reset_) begin
    addr_first_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_first_aw_seen <= 1'd1;
  end
end

always @(posedge clk) begin
    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;
end


endmodule"
ram,ram_3,"write after write cases, where writes to the same address happen before a read, does not occur. Use the signals 'we', 'wa', 'symbolic_constant_a', and 'addr_aw_seen'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
     (addr_aw_seen |-> !(we && (wa == symbolic_constant_a)))
);","module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);

  
    parameter   addr_width = 1;
    parameter   data_width = 1;
    parameter   entries = 1;
    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check


parameter tb_max_length_width = $clog2(wr_latency);

input    clk,reset_;
input    we,re;
input [addr_width-1:0] wa,ra;
input [data_width-1:0] wd,rd;
input    stall;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [addr_width-1:0] symbolic_constant_a;
asum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)
  ($stable(symbolic_constant_a))
);

reg addr_ar_seen;
reg addr_aw_seen;
reg addr_first_aw_seen;
reg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       

always @(posedge clk) begin
  if(!reset_) begin
    addr_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd1;    
  end else if (re && (ra == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd0;    
  end
end
always @(posedge clk) begin
  if(!reset_) begin
    addr_ar_seen <= 1'd0;
  end else if (we && (re == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd1;    
  end else if (re && (we == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd0;    
  end
end

always @(posedge clk) begin
  if(!reset_) begin
    addr_first_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_first_aw_seen <= 1'd1;
  end
end

always @(posedge clk) begin
    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;
end


endmodule"
ram,ram_4,"read after read cases, where read to the same address happen before a write, does not occur. Use the signals 're', 'ra', 'symbolic_constant_a', and 'addr_ar_seen'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (addr_ar_seen |-> !(re && (ra == symbolic_constant_a)))
);","module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);

  
    parameter   addr_width = 1;
    parameter   data_width = 1;
    parameter   entries = 1;
    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check


parameter tb_max_length_width = $clog2(wr_latency);

input    clk,reset_;
input    we,re;
input [addr_width-1:0] wa,ra;
input [data_width-1:0] wd,rd;
input    stall;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [addr_width-1:0] symbolic_constant_a;
asum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)
  ($stable(symbolic_constant_a))
);

reg addr_ar_seen;
reg addr_aw_seen;
reg addr_first_aw_seen;
reg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       

always @(posedge clk) begin
  if(!reset_) begin
    addr_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd1;    
  end else if (re && (ra == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd0;    
  end
end
always @(posedge clk) begin
  if(!reset_) begin
    addr_ar_seen <= 1'd0;
  end else if (we && (re == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd1;    
  end else if (re && (we == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd0;    
  end
end

always @(posedge clk) begin
  if(!reset_) begin
    addr_first_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_first_aw_seen <= 1'd1;
  end
end

always @(posedge clk) begin
    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;
end


endmodule"
ram,ram_5,"read before write cases, where read to the same address happen before a write, does not occur. Use the signals 're', 'ra', 'symbolic_constant_a', and 'addr_first_aw_seen'.","asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (!addr_first_aw_seen |-> !(re && (ra == symbolic_constant_a)))
);","module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);

  
    parameter   addr_width = 1;
    parameter   data_width = 1;
    parameter   entries = 1;
    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check


parameter tb_max_length_width = $clog2(wr_latency);

input    clk,reset_;
input    we,re;
input [addr_width-1:0] wa,ra;
input [data_width-1:0] wd,rd;
input    stall;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [addr_width-1:0] symbolic_constant_a;
asum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)
  ($stable(symbolic_constant_a))
);

reg addr_ar_seen;
reg addr_aw_seen;
reg addr_first_aw_seen;
reg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       

always @(posedge clk) begin
  if(!reset_) begin
    addr_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd1;    
  end else if (re && (ra == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd0;    
  end
end
always @(posedge clk) begin
  if(!reset_) begin
    addr_ar_seen <= 1'd0;
  end else if (we && (re == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd1;    
  end else if (re && (we == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd0;    
  end
end

always @(posedge clk) begin
  if(!reset_) begin
    addr_first_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_first_aw_seen <= 1'd1;
  end
end

always @(posedge clk) begin
    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;
end


endmodule"
ram,ram_6,max latency between a write and following read is within the specified write-read latency threshold. Use the signal 'latency_cnt'.,"asrt: assert property (@(posedge clk) disable iff (tb_reset)
    (latency_cnt <= wr_latency)
);","module ram_tb (clk, reset_, we, wa, wd, re, ra, rd, stall);

  
    parameter   addr_width = 1;
    parameter   data_width = 1;
    parameter   entries = 1;
    parameter   wr_latency=0;                   //checks max latency between a write to read. wr_latency=0 means disable this check


parameter tb_max_length_width = $clog2(wr_latency);

input    clk,reset_;
input    we,re;
input [addr_width-1:0] wa,ra;
input [data_width-1:0] wd,rd;
input    stall;

wire tb_reset;
assign tb_reset = (reset_ == 1'b0);


wire [addr_width-1:0] symbolic_constant_a;
asum_tb_ram__constant_addr_a : assume property (@(posedge clk) disable iff (tb_reset)
  ($stable(symbolic_constant_a))
);

reg addr_ar_seen;
reg addr_aw_seen;
reg addr_first_aw_seen;
reg [tb_max_length_width-1:0]  latency_cnt;       //max latency is wr_latency       

always @(posedge clk) begin
  if(!reset_) begin
    addr_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd1;    
  end else if (re && (ra == symbolic_constant_a)) begin
    addr_aw_seen <= 1'd0;    
  end
end
always @(posedge clk) begin
  if(!reset_) begin
    addr_ar_seen <= 1'd0;
  end else if (we && (re == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd1;    
  end else if (re && (we == symbolic_constant_a)) begin
    addr_ar_seen <= 1'd0;    
  end
end

always @(posedge clk) begin
  if(!reset_) begin
    addr_first_aw_seen <= 1'd0;
  end else if (we && (wa == symbolic_constant_a)) begin
    addr_first_aw_seen <= 1'd1;
  end
end

always @(posedge clk) begin
    latency_cnt <= (we && wa == symbolic_constant_a) ? 16'd1 : (re && ra == symbolic_constant_a) ? 16'd0 : (latency_cnt>0) ? (latency_cnt+(!stall)) : latency_cnt;
end


endmodule"
